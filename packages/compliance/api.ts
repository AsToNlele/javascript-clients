/* tslint:disable */
/* eslint-disable */
/**
 * Cloud Services for RHEL Compliance API v2
 * This is the API for Cloud Services for RHEL Compliance. You can find out more about Red Hat Cloud Services for RHEL at [https://console.redhat.com/](https://console.redhat.com/)
 *
 * The version of the OpenAPI document: v2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface AssignRulesRequest
 */
export interface AssignRulesRequest {
    /**
     *
     * @type {any}
     * @memberof AssignRulesRequest
     */
    'ids'?: any;
}
/**
 *
 * @export
 * @interface CreatePolicy201Response
 */
export interface CreatePolicy201Response {
    /**
     *
     * @type {CreatePolicy201ResponseData}
     * @memberof CreatePolicy201Response
     */
    'data'?: CreatePolicy201ResponseData;
}
/**
 *
 * @export
 * @interface CreatePolicy201ResponseData
 */
export interface CreatePolicy201ResponseData {
    /**
     *
     * @type {Policy}
     * @memberof CreatePolicy201ResponseData
     */
    'schema'?: Policy;
}
/**
 *
 * @export
 * @interface Errors
 */
export interface Errors {
    /**
     *
     * @type {any}
     * @memberof Errors
     */
    'errors': any;
}
/**
 *
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * Link to first page
     * @type {any}
     * @memberof Links
     */
    'first'?: any;
    /**
     * Link to last page
     * @type {any}
     * @memberof Links
     */
    'last'?: any;
    /**
     * Link to previous page
     * @type {any}
     * @memberof Links
     */
    'previous'?: any;
    /**
     * Link to next page
     * @type {any}
     * @memberof Links
     */
    'next'?: any;
}
/**
 *
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * Total number of items
     * @type {any}
     * @memberof Metadata
     */
    'total'?: any;
    /**
     * Number of items returned per page
     * @type {any}
     * @memberof Metadata
     */
    'limit'?: any;
    /**
     * Offset of the first item of paginated response
     * @type {any}
     * @memberof Metadata
     */
    'offset'?: any;
    /**
     * Attribute and direction the items are sorted by
     * @type {any}
     * @memberof Metadata
     */
    'sort_by'?: any;
    /**
     * Query string used to filter items by their attributes
     * @type {any}
     * @memberof Metadata
     */
    'filter'?: any;
}
/**
 *
 * @export
 * @interface Policies200Response
 */
export interface Policies200Response {
    /**
     *
     * @type {Metadata}
     * @memberof Policies200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof Policies200Response
     */
    'links'?: Links;
    /**
     *
     * @type {any}
     * @memberof Policies200Response
     */
    'data'?: any;
}
/**
 *
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     *
     * @type {any}
     * @memberof Policy
     */
    'id'?: any;
    /**
     *
     * @type {any}
     * @memberof Policy
     */
    'type'?: PolicyTypeEnum;
    /**
     * Short title of the Policy
     * @type {any}
     * @memberof Policy
     */
    'title'?: any;
    /**
     * Longer description of the Policy
     * @type {any}
     * @memberof Policy
     */
    'description'?: any;
    /**
     * The Business Objective associated to the Policy
     * @type {any}
     * @memberof Policy
     */
    'business_objective'?: any;
    /**
     * The percentage above which the Policy meets compliance requirements
     * @type {any}
     * @memberof Policy
     */
    'compliance_threshold': any;
    /**
     * Identifier of the underlying Profile
     * @type {any}
     * @memberof Policy
     */
    'profile_id': any;
    /**
     * Major version of the Operating System that the Policy covers
     * @type {any}
     * @memberof Policy
     */
    'os_major_version'?: any;
    /**
     * Identificator of the Profile
     * @type {any}
     * @memberof Policy
     */
    'ref_id'?: any;
    /**
     * Title of the associated Policy
     * @type {any}
     * @memberof Policy
     */
    'profile_title'?: any;
    /**
     * The number of Systems assigned to this Policy
     * @type {any}
     * @memberof Policy
     */
    'total_system_count'?: any;
}

export const PolicyTypeEnum = {
    Policy: 'policy'
} as const;

export type PolicyTypeEnum = typeof PolicyTypeEnum[keyof typeof PolicyTypeEnum];

/**
 *
 * @export
 * @interface PolicyUpdate
 */
export interface PolicyUpdate {
    /**
     * Longer description of the Policy
     * @type {any}
     * @memberof PolicyUpdate
     */
    'description'?: any;
    /**
     * The Business Objective associated to the Policy
     * @type {any}
     * @memberof PolicyUpdate
     */
    'business_objective'?: any;
    /**
     * The percentage above which the Policy meets compliance requirements
     * @type {any}
     * @memberof PolicyUpdate
     */
    'compliance_threshold'?: any;
}
/**
 *
 * @export
 * @interface Profile
 */
export interface Profile {
    /**
     *
     * @type {any}
     * @memberof Profile
     */
    'id'?: any;
    /**
     *
     * @type {any}
     * @memberof Profile
     */
    'type'?: ProfileTypeEnum;
    /**
     * Identificator of the Profile
     * @type {any}
     * @memberof Profile
     */
    'ref_id'?: any;
    /**
     * Short title of the Profile
     * @type {any}
     * @memberof Profile
     */
    'title'?: any;
    /**
     * Longer description of the Profile
     * @type {any}
     * @memberof Profile
     */
    'description'?: any;
    /**
     * Pair of keys and values for Value Definition customizations
     * @type {any}
     * @memberof Profile
     */
    'value_overrides'?: any;
}

export const ProfileTypeEnum = {
    Profile: 'profile'
} as const;

export type ProfileTypeEnum = typeof ProfileTypeEnum[keyof typeof ProfileTypeEnum];

/**
 *
 * @export
 * @interface Profile200Response
 */
export interface Profile200Response {
    /**
     *
     * @type {Profile200ResponseData}
     * @memberof Profile200Response
     */
    'data'?: Profile200ResponseData;
}
/**
 *
 * @export
 * @interface Profile200ResponseData
 */
export interface Profile200ResponseData {
    /**
     *
     * @type {Profile}
     * @memberof Profile200ResponseData
     */
    'schema'?: Profile;
}
/**
 *
 * @export
 * @interface Profiles200Response
 */
export interface Profiles200Response {
    /**
     *
     * @type {Metadata}
     * @memberof Profiles200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof Profiles200Response
     */
    'links'?: Links;
    /**
     *
     * @type {any}
     * @memberof Profiles200Response
     */
    'data'?: any;
}
/**
 *
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     *
     * @type {any}
     * @memberof Rule
     */
    'id'?: any;
    /**
     *
     * @type {any}
     * @memberof Rule
     */
    'type'?: RuleTypeEnum;
    /**
     * Identificator of the Rule
     * @type {any}
     * @memberof Rule
     */
    'ref_id'?: any;
    /**
     * Short title of the Rule
     * @type {any}
     * @memberof Rule
     */
    'title'?: any;
    /**
     * Rationale of the Rule
     * @type {any}
     * @memberof Rule
     */
    'rationale'?: any;
    /**
     * Longer description of the Rule
     * @type {any}
     * @memberof Rule
     */
    'description'?: any;
    /**
     * The original sorting precedence of the Rule in the Security Guide
     * @type {any}
     * @memberof Rule
     */
    'precedence'?: any;
    /**
     * The severity of the Rule
     * @type {any}
     * @memberof Rule
     */
    'severity'?: any;
    /**
     * The idenfitier of the remediation associated to this rule, only available under profiles.
     * @type {any}
     * @memberof Rule
     */
    'remediation_issue_id'?: any;
}

export const RuleTypeEnum = {
    Rule: 'rule'
} as const;

export type RuleTypeEnum = typeof RuleTypeEnum[keyof typeof RuleTypeEnum];

/**
 *
 * @export
 * @interface Rule200Response
 */
export interface Rule200Response {
    /**
     *
     * @type {Rule200ResponseData}
     * @memberof Rule200Response
     */
    'data'?: Rule200ResponseData;
}
/**
 *
 * @export
 * @interface Rule200ResponseData
 */
export interface Rule200ResponseData {
    /**
     *
     * @type {Rule}
     * @memberof Rule200ResponseData
     */
    'schema'?: Rule;
}
/**
 *
 * @export
 * @interface RuleGroup
 */
export interface RuleGroup {
    /**
     *
     * @type {any}
     * @memberof RuleGroup
     */
    'id'?: any;
    /**
     *
     * @type {any}
     * @memberof RuleGroup
     */
    'type'?: RuleGroupTypeEnum;
    /**
     * Identificator of the Rule Group
     * @type {any}
     * @memberof RuleGroup
     */
    'ref_id'?: any;
    /**
     * Short title of the Rule Group
     * @type {any}
     * @memberof RuleGroup
     */
    'title'?: any;
    /**
     * Rationale of the Rule Group
     * @type {any}
     * @memberof RuleGroup
     */
    'rationale'?: any;
    /**
     * Longer description of the Rule Group
     * @type {any}
     * @memberof RuleGroup
     */
    'description'?: any;
    /**
     * The original sorting precedence of the Rule Group in the Security Guide
     * @type {any}
     * @memberof RuleGroup
     */
    'precedence'?: any;
}

export const RuleGroupTypeEnum = {
    RuleGroup: 'rule_group'
} as const;

export type RuleGroupTypeEnum = typeof RuleGroupTypeEnum[keyof typeof RuleGroupTypeEnum];

/**
 *
 * @export
 * @interface RuleGroup200Response
 */
export interface RuleGroup200Response {
    /**
     *
     * @type {RuleGroup200ResponseData}
     * @memberof RuleGroup200Response
     */
    'data'?: RuleGroup200ResponseData;
}
/**
 *
 * @export
 * @interface RuleGroup200ResponseData
 */
export interface RuleGroup200ResponseData {
    /**
     *
     * @type {RuleGroup}
     * @memberof RuleGroup200ResponseData
     */
    'schema'?: RuleGroup;
}
/**
 *
 * @export
 * @interface RuleGroups200Response
 */
export interface RuleGroups200Response {
    /**
     *
     * @type {Metadata}
     * @memberof RuleGroups200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof RuleGroups200Response
     */
    'links'?: Links;
    /**
     *
     * @type {any}
     * @memberof RuleGroups200Response
     */
    'data'?: any;
}
/**
 *
 * @export
 * @interface Rules200Response
 */
export interface Rules200Response {
    /**
     *
     * @type {Metadata}
     * @memberof Rules200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof Rules200Response
     */
    'links'?: Links;
    /**
     *
     * @type {any}
     * @memberof Rules200Response
     */
    'data'?: any;
}
/**
 *
 * @export
 * @interface SecurityGuide
 */
export interface SecurityGuide {
    /**
     *
     * @type {any}
     * @memberof SecurityGuide
     */
    'id'?: any;
    /**
     *
     * @type {any}
     * @memberof SecurityGuide
     */
    'type'?: SecurityGuideTypeEnum;
    /**
     * Identificator of the Security Guide
     * @type {any}
     * @memberof SecurityGuide
     */
    'ref_id'?: any;
    /**
     * Short title of the Security Guide
     * @type {any}
     * @memberof SecurityGuide
     */
    'title'?: any;
    /**
     * Version of the Security Guide
     * @type {any}
     * @memberof SecurityGuide
     */
    'version'?: any;
    /**
     * Longer description of the Security Guide
     * @type {any}
     * @memberof SecurityGuide
     */
    'description'?: any;
    /**
     * Major version of the Operating System that the Security Guide covers
     * @type {any}
     * @memberof SecurityGuide
     */
    'os_major_version'?: any;
}

export const SecurityGuideTypeEnum = {
    SecurityGuide: 'security_guide'
} as const;

export type SecurityGuideTypeEnum = typeof SecurityGuideTypeEnum[keyof typeof SecurityGuideTypeEnum];

/**
 *
 * @export
 * @interface SecurityGuide200Response
 */
export interface SecurityGuide200Response {
    /**
     *
     * @type {SecurityGuide200ResponseData}
     * @memberof SecurityGuide200Response
     */
    'data'?: SecurityGuide200ResponseData;
}
/**
 *
 * @export
 * @interface SecurityGuide200ResponseData
 */
export interface SecurityGuide200ResponseData {
    /**
     *
     * @type {SecurityGuide}
     * @memberof SecurityGuide200ResponseData
     */
    'schema'?: SecurityGuide;
}
/**
 *
 * @export
 * @interface SecurityGuides200Response
 */
export interface SecurityGuides200Response {
    /**
     *
     * @type {Metadata}
     * @memberof SecurityGuides200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof SecurityGuides200Response
     */
    'links'?: Links;
    /**
     *
     * @type {any}
     * @memberof SecurityGuides200Response
     */
    'data'?: any;
}
/**
 *
 * @export
 * @interface SupportedProfile
 */
export interface SupportedProfile {
    /**
     *
     * @type {any}
     * @memberof SupportedProfile
     */
    'id'?: any;
    /**
     *
     * @type {any}
     * @memberof SupportedProfile
     */
    'type'?: SupportedProfileTypeEnum;
    /**
     * Identificator of the Profile
     * @type {any}
     * @memberof SupportedProfile
     */
    'ref_id'?: any;
    /**
     * Short title of the Profile
     * @type {any}
     * @memberof SupportedProfile
     */
    'title'?: any;
    /**
     * Version of the latest Security Guide supporting this Profile
     * @type {any}
     * @memberof SupportedProfile
     */
    'security_guide_version'?: any;
    /**
     * Major version of the Operating System that the Profile covers
     * @type {any}
     * @memberof SupportedProfile
     */
    'os_major_version'?: any;
    /**
     * List of the supported Operating System minor versions that the Profile covers
     * @type {any}
     * @memberof SupportedProfile
     */
    'os_minor_versions'?: any;
}

export const SupportedProfileTypeEnum = {
    SupportedProfile: 'supported_profile'
} as const;

export type SupportedProfileTypeEnum = typeof SupportedProfileTypeEnum[keyof typeof SupportedProfileTypeEnum];

/**
 *
 * @export
 * @interface SupportedProfiles200Response
 */
export interface SupportedProfiles200Response {
    /**
     *
     * @type {Metadata}
     * @memberof SupportedProfiles200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof SupportedProfiles200Response
     */
    'links'?: Links;
    /**
     *
     * @type {any}
     * @memberof SupportedProfiles200Response
     */
    'data'?: any;
}
/**
 *
 * @export
 * @interface System
 */
export interface System {
    /**
     *
     * @type {any}
     * @memberof System
     */
    'id'?: any;
    /**
     *
     * @type {any}
     * @memberof System
     */
    'type'?: SystemTypeEnum;
    /**
     * Display Name of the System
     * @type {any}
     * @memberof System
     */
    'display_name'?: any;
    /**
     *
     * @type {any}
     * @memberof System
     */
    'groups'?: any;
    /**
     *
     * @type {any}
     * @memberof System
     */
    'culled_timestamp'?: any;
    /**
     *
     * @type {any}
     * @memberof System
     */
    'stale_timestamp'?: any;
    /**
     *
     * @type {any}
     * @memberof System
     */
    'stale_warning_timestamp'?: any;
    /**
     *
     * @type {any}
     * @memberof System
     */
    'updated'?: any;
    /**
     *
     * @type {any}
     * @memberof System
     */
    'insights_id'?: any;
    /**
     *
     * @type {any}
     * @memberof System
     */
    'tags'?: any;
    /**
     * Major version of the Operating System
     * @type {any}
     * @memberof System
     */
    'os_major_version'?: any;
    /**
     * Minor version of the Operating System
     * @type {any}
     * @memberof System
     */
    'os_minor_version'?: any;
    /**
     * List of Policies assigned to the System, visible only when not listing Systems under a given Policy
     * @type {any}
     * @memberof System
     */
    'policies'?: any;
}

export const SystemTypeEnum = {
    System: 'system'
} as const;

export type SystemTypeEnum = typeof SystemTypeEnum[keyof typeof SystemTypeEnum];

/**
 *
 * @export
 * @interface System200Response
 */
export interface System200Response {
    /**
     *
     * @type {System200ResponseData}
     * @memberof System200Response
     */
    'data'?: System200ResponseData;
}
/**
 *
 * @export
 * @interface System200ResponseData
 */
export interface System200ResponseData {
    /**
     *
     * @type {System}
     * @memberof System200ResponseData
     */
    'schema'?: System;
}
/**
 *
 * @export
 * @interface Systems200Response
 */
export interface Systems200Response {
    /**
     *
     * @type {Metadata}
     * @memberof Systems200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof Systems200Response
     */
    'links'?: Links;
    /**
     *
     * @type {any}
     * @memberof Systems200Response
     */
    'data'?: any;
}
/**
 *
 * @export
 * @interface Tailoring
 */
export interface Tailoring {
    /**
     *
     * @type {any}
     * @memberof Tailoring
     */
    'id'?: any;
    /**
     *
     * @type {any}
     * @memberof Tailoring
     */
    'type'?: TailoringTypeEnum;
    /**
     * Identificator of the Profile from which the Tailoring was cloned
     * @type {any}
     * @memberof Tailoring
     */
    'profile_id'?: any;
    /**
     * Major version of the Operating System that the Tailoring covers
     * @type {any}
     * @memberof Tailoring
     */
    'os_major_version'?: any;
    /**
     * Minor version of the Operating System that the Tailoring covers
     * @type {any}
     * @memberof Tailoring
     */
    'os_minor_version'?: any;
    /**
     * Pair of keys and values for Value Definition customizations
     * @type {any}
     * @memberof Tailoring
     */
    'value_overrides'?: any;
}

export const TailoringTypeEnum = {
    Tailoring: 'tailoring'
} as const;

export type TailoringTypeEnum = typeof TailoringTypeEnum[keyof typeof TailoringTypeEnum];

/**
 *
 * @export
 * @interface Tailoring200Response
 */
export interface Tailoring200Response {
    /**
     *
     * @type {Tailoring200ResponseData}
     * @memberof Tailoring200Response
     */
    'data'?: Tailoring200ResponseData;
}
/**
 *
 * @export
 * @interface Tailoring200ResponseData
 */
export interface Tailoring200ResponseData {
    /**
     *
     * @type {Tailoring}
     * @memberof Tailoring200ResponseData
     */
    'schema'?: Tailoring;
}
/**
 * Defines customizations of rules and variables for a set of profiles
 * @export
 * @interface TailoringFile
 */
export interface TailoringFile {
    [key: string]: any;

    /**
     *
     * @type {any}
     * @memberof TailoringFile
     */
    'profiles'?: any;
}
/**
 *
 * @export
 * @interface Tailorings200Response
 */
export interface Tailorings200Response {
    /**
     *
     * @type {Metadata}
     * @memberof Tailorings200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof Tailorings200Response
     */
    'links'?: Links;
    /**
     *
     * @type {any}
     * @memberof Tailorings200Response
     */
    'data'?: any;
}
/**
 *
 * @export
 * @interface ValueDefinition
 */
export interface ValueDefinition {
    /**
     *
     * @type {any}
     * @memberof ValueDefinition
     */
    'id'?: any;
    /**
     *
     * @type {any}
     * @memberof ValueDefinition
     */
    'type'?: ValueDefinitionTypeEnum;
    /**
     * Identificator of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'ref_id'?: any;
    /**
     * Short title of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'title'?: any;
    /**
     * Type of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'value_type'?: any;
    /**
     * Longer description of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'description'?: any;
    /**
     * Default value of the Value Definition
     * @type {any}
     * @memberof ValueDefinition
     */
    'default_value'?: any;
}

export const ValueDefinitionTypeEnum = {
    ValueDefinition: 'value_definition'
} as const;

export type ValueDefinitionTypeEnum = typeof ValueDefinitionTypeEnum[keyof typeof ValueDefinitionTypeEnum];

/**
 *
 * @export
 * @interface ValueDefinition200Response
 */
export interface ValueDefinition200Response {
    /**
     *
     * @type {ValueDefinition200ResponseData}
     * @memberof ValueDefinition200Response
     */
    'data'?: ValueDefinition200ResponseData;
}
/**
 *
 * @export
 * @interface ValueDefinition200ResponseData
 */
export interface ValueDefinition200ResponseData {
    /**
     *
     * @type {ValueDefinition}
     * @memberof ValueDefinition200ResponseData
     */
    'schema'?: ValueDefinition;
}
/**
 *
 * @export
 * @interface ValueDefinitions200Response
 */
export interface ValueDefinitions200Response {
    /**
     *
     * @type {Metadata}
     * @memberof ValueDefinitions200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof ValueDefinitions200Response
     */
    'links'?: Links;
    /**
     *
     * @type {any}
     * @memberof ValueDefinitions200Response
     */
    'data'?: any;
}

/**
 * ContentApi - axios parameter creator
 * @export
 */
export const ContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Profile
         * @summary Request a Profile
         * @param {any} securityGuideId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile: async (securityGuideId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profile', 'securityGuideId', securityGuideId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profile', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/profiles/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Rule assigned to a Profile
         * @summary Request a Rule assigned to a Profile
         * @param {any} securityGuideId
         * @param {any} profileId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRule: async (securityGuideId: any, profileId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profileRule', 'securityGuideId', securityGuideId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('profileRule', 'profileId', profileId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profileRule', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/profiles/{profile_id}/rules/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Rules assigned to a Profile
         * @summary Request Rules assigned to a Profile
         * @param {any} securityGuideId
         * @param {any} profileId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRules: async (securityGuideId: any, profileId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profileRules', 'securityGuideId', securityGuideId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('profileRules', 'profileId', profileId)
            const localVarPath = `/security_guides/{security_guide_id}/profiles/{profile_id}/rules`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Profiles
         * @summary Request Profiles
         * @param {any} securityGuideId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profiles: async (securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profiles', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/profiles`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Rule
         * @summary Request a Rule
         * @param {any} securityGuideId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rule: async (securityGuideId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('rule', 'securityGuideId', securityGuideId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rule', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/rules/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Rule Group
         * @summary Request a Rule Group
         * @param {any} securityGuideId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroup: async (securityGuideId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('ruleGroup', 'securityGuideId', securityGuideId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleGroup', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/rule_groups/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Rule Groups
         * @summary Request Rule Groups
         * @param {any} securityGuideId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroups: async (securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('ruleGroups', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/rule_groups`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Rules assigned
         * @summary Request Rules
         * @param {any} securityGuideId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rules: async (securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('rules', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/rules`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Security Guide
         * @summary Request a Security Guide
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuide: async (id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGuide', 'id', id)
            const localVarPath = `/security_guides/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Rule Tree of a Security Guide
         * @summary Request the Rule Tree of a Security Guide
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuideRuleTree: async (id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGuideRuleTree', 'id', id)
            const localVarPath = `/security_guides/{id}/rule_tree`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Security Guides
         * @summary Request Security Guides
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuides: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/security_guides`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Supported Profiles
         * @summary Request Supported Profiles
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportedProfiles: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/security_guides/supported_profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Value Definition
         * @summary Request a Value Definition
         * @param {any} securityGuideId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinition: async (securityGuideId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('valueDefinition', 'securityGuideId', securityGuideId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('valueDefinition', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/value_definitions/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Value Definitions
         * @summary Request Value Definitions
         * @param {any} securityGuideId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinitions: async (securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('valueDefinitions', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/value_definitions`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Profile
         * @summary Request a Profile
         * @param {any} securityGuideId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profile(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profile(securityGuideId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Rule assigned to a Profile
         * @summary Request a Rule assigned to a Profile
         * @param {any} securityGuideId
         * @param {any} profileId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileRule(securityGuideId: any, profileId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileRule(securityGuideId, profileId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Rules assigned to a Profile
         * @summary Request Rules assigned to a Profile
         * @param {any} securityGuideId
         * @param {any} profileId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileRules(securityGuideId: any, profileId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileRules(securityGuideId, profileId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Profiles
         * @summary Request Profiles
         * @param {any} securityGuideId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profiles(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profiles(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Rule
         * @summary Request a Rule
         * @param {any} securityGuideId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rule(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rule(securityGuideId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Rule Group
         * @summary Request a Rule Group
         * @param {any} securityGuideId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleGroup(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleGroup(securityGuideId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Rule Groups
         * @summary Request Rule Groups
         * @param {any} securityGuideId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleGroups(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleGroups(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Rules assigned
         * @summary Request Rules
         * @param {any} securityGuideId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rules(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rules(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Security Guide
         * @summary Request a Security Guide
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGuide(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGuide200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGuide(id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the Rule Tree of a Security Guide
         * @summary Request the Rule Tree of a Security Guide
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGuideRuleTree(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGuideRuleTree(id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Security Guides
         * @summary Request Security Guides
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGuides(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGuides200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGuides(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Supported Profiles
         * @summary Request Supported Profiles
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportedProfiles(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportedProfiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportedProfiles(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Value Definition
         * @summary Request a Value Definition
         * @param {any} securityGuideId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async valueDefinition(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueDefinition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.valueDefinition(securityGuideId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Value Definitions
         * @summary Request Value Definitions
         * @param {any} securityGuideId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async valueDefinitions(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueDefinitions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.valueDefinitions(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentApiFp(configuration)
    return {
        /**
         * Returns a Profile
         * @summary Request a Profile
         * @param {any} securityGuideId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<Profile200Response> {
            return localVarFp.profile(securityGuideId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Rule assigned to a Profile
         * @summary Request a Rule assigned to a Profile
         * @param {any} securityGuideId
         * @param {any} profileId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRule(securityGuideId: any, profileId: any, id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<Rule200Response> {
            return localVarFp.profileRule(securityGuideId, profileId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Rules assigned to a Profile
         * @summary Request Rules assigned to a Profile
         * @param {any} securityGuideId
         * @param {any} profileId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRules(securityGuideId: any, profileId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: any): AxiosPromise<Rules200Response> {
            return localVarFp.profileRules(securityGuideId, profileId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Profiles
         * @summary Request Profiles
         * @param {any} securityGuideId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profiles(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: any): AxiosPromise<Profiles200Response> {
            return localVarFp.profiles(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Rule
         * @summary Request a Rule
         * @param {any} securityGuideId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rule(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<Rule200Response> {
            return localVarFp.rule(securityGuideId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Rule Group
         * @summary Request a Rule Group
         * @param {any} securityGuideId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroup(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<RuleGroup200Response> {
            return localVarFp.ruleGroup(securityGuideId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Rule Groups
         * @summary Request Rule Groups
         * @param {any} securityGuideId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroups(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: any): AxiosPromise<RuleGroups200Response> {
            return localVarFp.ruleGroups(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Rules assigned
         * @summary Request Rules
         * @param {any} securityGuideId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rules(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: any): AxiosPromise<Rules200Response> {
            return localVarFp.rules(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Security Guide
         * @summary Request a Security Guide
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuide(id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<SecurityGuide200Response> {
            return localVarFp.securityGuide(id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Rule Tree of a Security Guide
         * @summary Request the Rule Tree of a Security Guide
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuideRuleTree(id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<any> {
            return localVarFp.securityGuideRuleTree(id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Security Guides
         * @summary Request Security Guides
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuides(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: any): AxiosPromise<SecurityGuides200Response> {
            return localVarFp.securityGuides(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Supported Profiles
         * @summary Request Supported Profiles
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportedProfiles(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: any): AxiosPromise<SupportedProfiles200Response> {
            return localVarFp.supportedProfiles(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Value Definition
         * @summary Request a Value Definition
         * @param {any} securityGuideId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinition(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<ValueDefinition200Response> {
            return localVarFp.valueDefinition(securityGuideId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Value Definitions
         * @summary Request Value Definitions
         * @param {any} securityGuideId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinitions(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: any): AxiosPromise<ValueDefinitions200Response> {
            return localVarFp.valueDefinitions(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI {
    /**
     * Returns a Profile
     * @summary Request a Profile
     * @param {any} securityGuideId
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public profile(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).profile(securityGuideId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Rule assigned to a Profile
     * @summary Request a Rule assigned to a Profile
     * @param {any} securityGuideId
     * @param {any} profileId
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public profileRule(securityGuideId: any, profileId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).profileRule(securityGuideId, profileId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Rules assigned to a Profile
     * @summary Request Rules assigned to a Profile
     * @param {any} securityGuideId
     * @param {any} profileId
     * @param {any} [xRHIDENTITY]
     * @param {any} [limit] Number of items to return per page
     * @param {any} [offset] Offset of first item of paginated response
     * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public profileRules(securityGuideId: any, profileId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).profileRules(securityGuideId, profileId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Profiles
     * @summary Request Profiles
     * @param {any} securityGuideId
     * @param {any} [xRHIDENTITY]
     * @param {any} [limit] Number of items to return per page
     * @param {any} [offset] Offset of first item of paginated response
     * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public profiles(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).profiles(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Rule
     * @summary Request a Rule
     * @param {any} securityGuideId
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public rule(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).rule(securityGuideId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Rule Group
     * @summary Request a Rule Group
     * @param {any} securityGuideId
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public ruleGroup(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).ruleGroup(securityGuideId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Rule Groups
     * @summary Request Rule Groups
     * @param {any} securityGuideId
     * @param {any} [xRHIDENTITY]
     * @param {any} [limit] Number of items to return per page
     * @param {any} [offset] Offset of first item of paginated response
     * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public ruleGroups(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).ruleGroups(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Rules assigned
     * @summary Request Rules
     * @param {any} securityGuideId
     * @param {any} [xRHIDENTITY]
     * @param {any} [limit] Number of items to return per page
     * @param {any} [offset] Offset of first item of paginated response
     * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public rules(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).rules(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Security Guide
     * @summary Request a Security Guide
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public securityGuide(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).securityGuide(id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Rule Tree of a Security Guide
     * @summary Request the Rule Tree of a Security Guide
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public securityGuideRuleTree(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).securityGuideRuleTree(id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Security Guides
     * @summary Request Security Guides
     * @param {any} [xRHIDENTITY]
     * @param {any} [limit] Number of items to return per page
     * @param {any} [offset] Offset of first item of paginated response
     * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public securityGuides(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).securityGuides(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Supported Profiles
     * @summary Request Supported Profiles
     * @param {any} [xRHIDENTITY]
     * @param {any} [limit] Number of items to return per page
     * @param {any} [offset] Offset of first item of paginated response
     * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public supportedProfiles(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).supportedProfiles(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Value Definition
     * @summary Request a Value Definition
     * @param {any} securityGuideId
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public valueDefinition(securityGuideId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).valueDefinition(securityGuideId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Value Definitions
     * @summary Request Value Definitions
     * @param {any} securityGuideId
     * @param {any} [xRHIDENTITY]
     * @param {any} [limit] Number of items to return per page
     * @param {any} [offset] Offset of first item of paginated response
     * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public valueDefinitions(securityGuideId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig) {
        return ContentApiFp(this.configuration).valueDefinitions(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns a Rule to a Tailoring
         * @summary Assign a Rule to a Tailoring
         * @param {any} policyId
         * @param {any} tailoringId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRule: async (policyId: any, tailoringId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignRule', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('assignRule', 'tailoringId', tailoringId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assignRule', 'id', id)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Rules to a Tailoring
         * @param {any} policyId
         * @param {any} tailoringId
         * @param {any} [xRHIDENTITY]
         * @param {AssignRulesRequest} [assignRulesRequest]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignRules: async (policyId: any, tailoringId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignRules', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('assignRules', 'tailoringId', tailoringId)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns a System to a Policy
         * @summary Assign a System to a Policy
         * @param {any} id
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignSystem: async (id: any, policyId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assignSystem', 'id', id)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignSystem', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Systems to a Policy
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {AssignRulesRequest} [assignRulesRequest]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignSystems: async (policyId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignSystems', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Policy with the provided attributes
         * @summary Create a Policy
         * @param {any} [xRHIDENTITY]
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy: async (xRHIDENTITY?: any, policy?: Policy, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Policy
         * @summary Delete a Policy
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy: async (id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePolicy', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Policies
         * @summary Request Policies
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policies: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Policy
         * @summary Request a Policy
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policy: async (id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('policy', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Systems assigned to a Policy
         * @summary Request Systems assigned to a Policy
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policySystems: async (policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policySystems', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Tailoring
         * @summary Request a Tailoring
         * @param {any} policyId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoring: async (policyId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailoring', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tailoring', 'id', id)
            const localVarPath = `/policies/{policy_id}/tailorings/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Tailoring File
         * @summary Request a Tailoring file
         * @param {any} policyId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringFile: async (policyId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailoringFile', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tailoringFile', 'id', id)
            const localVarPath = `/policies/{policy_id}/tailorings/{id}/tailoring_file.json`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Rules assigned to a Tailoring
         * @summary Request Rules assigned to a Tailoring
         * @param {any} policyId
         * @param {any} tailoringId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringRules: async (policyId: any, tailoringId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailoringRules', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('tailoringRules', 'tailoringId', tailoringId)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Tailorings
         * @summary Request Tailorings
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailorings: async (policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailorings', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/tailorings`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unassigns a Rule from a Tailoring
         * @summary Unassign a Rule from a Tailoring
         * @param {any} policyId
         * @param {any} tailoringId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignRule: async (policyId: any, tailoringId: any, id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('unassignRule', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('unassignRule', 'tailoringId', tailoringId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unassignRule', 'id', id)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unassigns a System from a Policy
         * @summary Unassign a System from a Policy
         * @param {any} id
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignSystem: async (id: any, policyId: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unassignSystem', 'id', id)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('unassignSystem', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Policy with the provided attributes
         * @summary Update a Policy
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {PolicyUpdate} [policyUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy: async (id: any, xRHIDENTITY?: any, policyUpdate?: PolicyUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePolicy', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Assigns a Rule to a Tailoring
         * @summary Assign a Rule to a Tailoring
         * @param {any} policyId
         * @param {any} tailoringId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignRule(policyId: any, tailoringId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignRule(policyId, tailoringId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Rules to a Tailoring
         * @param {any} policyId
         * @param {any} tailoringId
         * @param {any} [xRHIDENTITY]
         * @param {AssignRulesRequest} [assignRulesRequest]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async assignRules(policyId: any, tailoringId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignRules(policyId, tailoringId, xRHIDENTITY, assignRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Assigns a System to a Policy
         * @summary Assign a System to a Policy
         * @param {any} id
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignSystem(id: any, policyId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignSystem(id, policyId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Systems to a Policy
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {AssignRulesRequest} [assignRulesRequest]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async assignSystems(policyId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Systems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignSystems(policyId, xRHIDENTITY, assignRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a Policy with the provided attributes
         * @summary Create a Policy
         * @param {any} [xRHIDENTITY]
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicy(xRHIDENTITY?: any, policy?: Policy, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicy(xRHIDENTITY, policy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Deletes a Policy
         * @summary Delete a Policy
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicy(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicy(id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Policies
         * @summary Request Policies
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policies(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policies(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Policy
         * @summary Request a Policy
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policy(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policy(id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Systems assigned to a Policy
         * @summary Request Systems assigned to a Policy
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policySystems(policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Systems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policySystems(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Tailoring
         * @summary Request a Tailoring
         * @param {any} policyId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailoring(policyId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tailoring200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailoring(policyId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a Tailoring File
         * @summary Request a Tailoring file
         * @param {any} policyId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailoringFile(policyId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TailoringFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailoringFile(policyId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Rules assigned to a Tailoring
         * @summary Request Rules assigned to a Tailoring
         * @param {any} policyId
         * @param {any} tailoringId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailoringRules(policyId: any, tailoringId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailoringRules(policyId, tailoringId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Tailorings
         * @summary Request Tailorings
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailorings(policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tailorings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailorings(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unassigns a Rule from a Tailoring
         * @summary Unassign a Rule from a Tailoring
         * @param {any} policyId
         * @param {any} tailoringId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unassignRule(policyId: any, tailoringId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unassignRule(policyId, tailoringId, id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unassigns a System from a Policy
         * @summary Unassign a System from a Policy
         * @param {any} id
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unassignSystem(id: any, policyId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unassignSystem(id, policyId, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates a Policy with the provided attributes
         * @summary Update a Policy
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {PolicyUpdate} [policyUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicy(id: any, xRHIDENTITY?: any, policyUpdate?: PolicyUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicy(id, xRHIDENTITY, policyUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * Assigns a Rule to a Tailoring
         * @summary Assign a Rule to a Tailoring
         * @param {any} policyId
         * @param {any} tailoringId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRule(policyId: any, tailoringId: any, id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<void> {
            return localVarFp.assignRule(policyId, tailoringId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Rules to a Tailoring
         * @param {any} policyId
         * @param {any} tailoringId
         * @param {any} [xRHIDENTITY]
         * @param {AssignRulesRequest} [assignRulesRequest]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignRules(policyId: any, tailoringId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options?: any): AxiosPromise<Rules200Response> {
            return localVarFp.assignRules(policyId, tailoringId, xRHIDENTITY, assignRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Assigns a System to a Policy
         * @summary Assign a System to a Policy
         * @param {any} id
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignSystem(id: any, policyId: any, xRHIDENTITY?: any, options?: any): AxiosPromise<System200Response> {
            return localVarFp.assignSystem(id, policyId, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Systems to a Policy
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {AssignRulesRequest} [assignRulesRequest]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignSystems(policyId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options?: any): AxiosPromise<Systems200Response> {
            return localVarFp.assignSystems(policyId, xRHIDENTITY, assignRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Policy with the provided attributes
         * @summary Create a Policy
         * @param {any} [xRHIDENTITY]
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy(xRHIDENTITY?: any, policy?: Policy, options?: any): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.createPolicy(xRHIDENTITY, policy, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Policy
         * @summary Delete a Policy
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.deletePolicy(id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Policies
         * @summary Request Policies
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policies(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: any): AxiosPromise<Policies200Response> {
            return localVarFp.policies(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Policy
         * @summary Request a Policy
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policy(id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.policy(id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Systems assigned to a Policy
         * @summary Request Systems assigned to a Policy
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policySystems(policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: any): AxiosPromise<Systems200Response> {
            return localVarFp.policySystems(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Tailoring
         * @summary Request a Tailoring
         * @param {any} policyId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoring(policyId: any, id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<Tailoring200Response> {
            return localVarFp.tailoring(policyId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Tailoring File
         * @summary Request a Tailoring file
         * @param {any} policyId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringFile(policyId: any, id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<TailoringFile> {
            return localVarFp.tailoringFile(policyId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Rules assigned to a Tailoring
         * @summary Request Rules assigned to a Tailoring
         * @param {any} policyId
         * @param {any} tailoringId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringRules(policyId: any, tailoringId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: any): AxiosPromise<Rules200Response> {
            return localVarFp.tailoringRules(policyId, tailoringId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Tailorings
         * @summary Request Tailorings
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailorings(policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: any): AxiosPromise<Tailorings200Response> {
            return localVarFp.tailorings(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Unassigns a Rule from a Tailoring
         * @summary Unassign a Rule from a Tailoring
         * @param {any} policyId
         * @param {any} tailoringId
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignRule(policyId: any, tailoringId: any, id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<void> {
            return localVarFp.unassignRule(policyId, tailoringId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Unassigns a System from a Policy
         * @summary Unassign a System from a Policy
         * @param {any} id
         * @param {any} policyId
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignSystem(id: any, policyId: any, xRHIDENTITY?: any, options?: any): AxiosPromise<System200Response> {
            return localVarFp.unassignSystem(id, policyId, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Policy with the provided attributes
         * @summary Update a Policy
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {PolicyUpdate} [policyUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(id: any, xRHIDENTITY?: any, policyUpdate?: PolicyUpdate, options?: any): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.updatePolicy(id, xRHIDENTITY, policyUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * Assigns a Rule to a Tailoring
     * @summary Assign a Rule to a Tailoring
     * @param {any} policyId
     * @param {any} tailoringId
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public assignRule(policyId: any, tailoringId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).assignRule(policyId, tailoringId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This feature is exclusively used by the frontend
     * @summary Bulk assign Rules to a Tailoring
     * @param {any} policyId
     * @param {any} tailoringId
     * @param {any} [xRHIDENTITY]
     * @param {AssignRulesRequest} [assignRulesRequest]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public assignRules(policyId: any, tailoringId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).assignRules(policyId, tailoringId, xRHIDENTITY, assignRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assigns a System to a Policy
     * @summary Assign a System to a Policy
     * @param {any} id
     * @param {any} policyId
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public assignSystem(id: any, policyId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).assignSystem(id, policyId, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This feature is exclusively used by the frontend
     * @summary Bulk assign Systems to a Policy
     * @param {any} policyId
     * @param {any} [xRHIDENTITY]
     * @param {AssignRulesRequest} [assignRulesRequest]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public assignSystems(policyId: any, xRHIDENTITY?: any, assignRulesRequest?: AssignRulesRequest, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).assignSystems(policyId, xRHIDENTITY, assignRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Policy with the provided attributes
     * @summary Create a Policy
     * @param {any} [xRHIDENTITY]
     * @param {Policy} [policy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createPolicy(xRHIDENTITY?: any, policy?: Policy, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createPolicy(xRHIDENTITY, policy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a Policy
     * @summary Delete a Policy
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public deletePolicy(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).deletePolicy(id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Policies
     * @summary Request Policies
     * @param {any} [xRHIDENTITY]
     * @param {any} [limit] Number of items to return per page
     * @param {any} [offset] Offset of first item of paginated response
     * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policies(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policies(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Policy
     * @summary Request a Policy
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policy(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policy(id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Systems assigned to a Policy
     * @summary Request Systems assigned to a Policy
     * @param {any} policyId
     * @param {any} [xRHIDENTITY]
     * @param {any} [limit] Number of items to return per page
     * @param {any} [offset] Offset of first item of paginated response
     * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policySystems(policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policySystems(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Tailoring
     * @summary Request a Tailoring
     * @param {any} policyId
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public tailoring(policyId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).tailoring(policyId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Tailoring File
     * @summary Request a Tailoring file
     * @param {any} policyId
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public tailoringFile(policyId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).tailoringFile(policyId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Rules assigned to a Tailoring
     * @summary Request Rules assigned to a Tailoring
     * @param {any} policyId
     * @param {any} tailoringId
     * @param {any} [xRHIDENTITY]
     * @param {any} [limit] Number of items to return per page
     * @param {any} [offset] Offset of first item of paginated response
     * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public tailoringRules(policyId: any, tailoringId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).tailoringRules(policyId, tailoringId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Tailorings
     * @summary Request Tailorings
     * @param {any} policyId
     * @param {any} [xRHIDENTITY]
     * @param {any} [limit] Number of items to return per page
     * @param {any} [offset] Offset of first item of paginated response
     * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public tailorings(policyId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).tailorings(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unassigns a Rule from a Tailoring
     * @summary Unassign a Rule from a Tailoring
     * @param {any} policyId
     * @param {any} tailoringId
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public unassignRule(policyId: any, tailoringId: any, id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).unassignRule(policyId, tailoringId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unassigns a System from a Policy
     * @summary Unassign a System from a Policy
     * @param {any} id
     * @param {any} policyId
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public unassignSystem(id: any, policyId: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).unassignSystem(id, policyId, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Policy with the provided attributes
     * @summary Update a Policy
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {PolicyUpdate} [policyUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public updatePolicy(id: any, xRHIDENTITY?: any, policyUpdate?: PolicyUpdate, options?: AxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updatePolicy(id, xRHIDENTITY, policyUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SystemsApi - axios parameter creator
 * @export
 */
export const SystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a System
         * @summary Request a System
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        system: async (id: any, xRHIDENTITY?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('system', 'id', id)
            const localVarPath = `/systems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Systems
         * @summary Request Systems
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systems: async (xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/systems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Policies under a System
         * @summary Request Policies assigned to a System
         * @param {any} systemId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemsPolicies: async (systemId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('systemsPolicies', 'systemId', systemId)
            const localVarPath = `/systems/{system_id}/policies`
                .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = typeof xRHIDENTITY === 'string'
                    ? xRHIDENTITY
                    : JSON.stringify(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemsApi - functional programming interface
 * @export
 */
export const SystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a System
         * @summary Request a System
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async system(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.system(id, xRHIDENTITY, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Systems
         * @summary Request Systems
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systems(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Systems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systems(xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lists Policies under a System
         * @summary Request Policies assigned to a System
         * @param {any} systemId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemsPolicies(systemId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemsPolicies(systemId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SystemsApi - factory interface
 * @export
 */
export const SystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemsApiFp(configuration)
    return {
        /**
         * Returns a System
         * @summary Request a System
         * @param {any} id
         * @param {any} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        system(id: any, xRHIDENTITY?: any, options?: any): AxiosPromise<System200Response> {
            return localVarFp.system(id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Systems
         * @summary Request Systems
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systems(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: any): AxiosPromise<Systems200Response> {
            return localVarFp.systems(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Policies under a System
         * @summary Request Policies assigned to a System
         * @param {any} systemId
         * @param {any} [xRHIDENTITY]
         * @param {any} [limit] Number of items to return per page
         * @param {any} [offset] Offset of first item of paginated response
         * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemsPolicies(systemId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: any): AxiosPromise<Policies200Response> {
            return localVarFp.systemsPolicies(systemId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemsApi - object-oriented interface
 * @export
 * @class SystemsApi
 * @extends {BaseAPI}
 */
export class SystemsApi extends BaseAPI {
    /**
     * Returns a System
     * @summary Request a System
     * @param {any} id
     * @param {any} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public system(id: any, xRHIDENTITY?: any, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).system(id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Systems
     * @summary Request Systems
     * @param {any} [xRHIDENTITY]
     * @param {any} [limit] Number of items to return per page
     * @param {any} [offset] Offset of first item of paginated response
     * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public systems(xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).systems(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Policies under a System
     * @summary Request Policies assigned to a System
     * @param {any} systemId
     * @param {any} [xRHIDENTITY]
     * @param {any} [limit] Number of items to return per page
     * @param {any} [offset] Offset of first item of paginated response
     * @param {any} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {any} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public systemsPolicies(systemId: any, xRHIDENTITY?: any, limit?: any, offset?: any, sortBy?: any, filter?: any, options?: AxiosRequestConfig) {
        return SystemsApiFp(this.configuration).systemsPolicies(systemId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }
}


