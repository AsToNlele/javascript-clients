/* tslint:disable */
/* eslint-disable */
/**
 * Cloud Services for RHEL Compliance API v2
 * This is the API for Cloud Services for RHEL Compliance. You can find out more about Red Hat Cloud Services for RHEL at [https://console.redhat.com/](https://console.redhat.com/)
 *
 * The version of the OpenAPI document: v2
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 *
 * @export
 * @interface AssignRulesRequest
 */
export interface AssignRulesRequest {
    /**
     *
     * @type {Array<string>}
     * @memberof AssignRulesRequest
     */
    'ids'?: Array<string>;
}
/**
 *
 * @export
 * @interface CreatePolicy201Response
 */
export interface CreatePolicy201Response {
    /**
     *
     * @type {Policies200ResponseDataInner}
     * @memberof CreatePolicy201Response
     */
    'data'?: Policies200ResponseDataInner;
}
/**
 *
 * @export
 * @interface Errors
 */
export interface Errors {
    /**
     *
     * @type {Array<string>}
     * @memberof Errors
     */
    'errors': Array<string>;
}
/**
 *
 * @export
 * @interface Links
 */
export interface Links {
    /**
     * Link to first page
     * @type {string}
     * @memberof Links
     */
    'first'?: string;
    /**
     * Link to last page
     * @type {string}
     * @memberof Links
     */
    'last'?: string;
    /**
     * Link to previous page
     * @type {string}
     * @memberof Links
     */
    'previous'?: string;
    /**
     * Link to next page
     * @type {string}
     * @memberof Links
     */
    'next'?: string;
}
/**
 *
 * @export
 * @interface Metadata
 */
export interface Metadata {
    /**
     * Total number of items
     * @type {number}
     * @memberof Metadata
     */
    'total'?: number;
    /**
     * Number of items returned per page
     * @type {number}
     * @memberof Metadata
     */
    'limit'?: number;
    /**
     * Offset of the first item of paginated response
     * @type {number}
     * @memberof Metadata
     */
    'offset'?: number;
    /**
     * Attribute and direction the items are sorted by
     * @type {string}
     * @memberof Metadata
     */
    'sort_by'?: string;
    /**
     * Query string used to filter items by their attributes
     * @type {string}
     * @memberof Metadata
     */
    'filter'?: string;
}
/**
 *
 * @export
 * @interface Policies200Response
 */
export interface Policies200Response {
    /**
     *
     * @type {Metadata}
     * @memberof Policies200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof Policies200Response
     */
    'links'?: Links;
    /**
     *
     * @type {Array<Policies200ResponseDataInner>}
     * @memberof Policies200Response
     */
    'data'?: Array<Policies200ResponseDataInner>;
}
/**
 *
 * @export
 * @interface Policies200ResponseDataInner
 */
export interface Policies200ResponseDataInner {
    /**
     *
     * @type {Policy}
     * @memberof Policies200ResponseDataInner
     */
    'schema'?: Policy;
}
/**
 *
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     *
     * @type {string}
     * @memberof Policy
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof Policy
     */
    'type'?: PolicyTypeEnum;
    /**
     * Short title of the Policy
     * @type {string}
     * @memberof Policy
     */
    'title'?: string;
    /**
     * Longer description of the Policy
     * @type {string}
     * @memberof Policy
     */
    'description'?: string;
    /**
     * The Business Objective associated to the Policy
     * @type {string}
     * @memberof Policy
     */
    'business_objective'?: string;
    /**
     * The percentage above which the Policy meets compliance requirements
     * @type {number}
     * @memberof Policy
     */
    'compliance_threshold': number;
    /**
     * Identifier of the underlying Profile
     * @type {string}
     * @memberof Policy
     */
    'profile_id': string;
    /**
     * Major version of the Operating System that the Policy covers
     * @type {number}
     * @memberof Policy
     */
    'os_major_version'?: number;
    /**
     * Identificator of the Profile
     * @type {string}
     * @memberof Policy
     */
    'ref_id'?: string;
    /**
     * Title of the associated Policy
     * @type {string}
     * @memberof Policy
     */
    'profile_title'?: string;
    /**
     * The number of Systems assigned to this Policy
     * @type {number}
     * @memberof Policy
     */
    'total_system_count'?: number;
}

export const PolicyTypeEnum = {
    Policy: 'policy'
} as const;

export type PolicyTypeEnum = typeof PolicyTypeEnum[keyof typeof PolicyTypeEnum];

/**
 *
 * @export
 * @interface PolicyUpdate
 */
export interface PolicyUpdate {
    /**
     * Longer description of the Policy
     * @type {string}
     * @memberof PolicyUpdate
     */
    'description'?: string;
    /**
     * The Business Objective associated to the Policy
     * @type {string}
     * @memberof PolicyUpdate
     */
    'business_objective'?: string;
    /**
     * The percentage above which the Policy meets compliance requirements
     * @type {number}
     * @memberof PolicyUpdate
     */
    'compliance_threshold'?: number;
}
/**
 * A new tailored profile with modifications
 * @export
 * @interface Profile
 */
export interface Profile {
    [key: string]: any;

    /**
     * New profile identifier, can be same as \'base_profile_id\', to \'shadow\' the origin
     * @type {any}
     * @memberof Profile
     */
    'id'?: any;
    /**
     * Original profile identifier, the base for modifications
     * @type {any}
     * @memberof Profile
     */
    'base_profile_id'?: any;
    /**
     * Title for the new profile, inherited from base profile if not given, required if there is no base profile
     * @type {any}
     * @memberof Profile
     */
    'title'?: any;
    /**
     * Group modifications, keys are identifiers
     * @type {object}
     * @memberof Profile
     */
    'groups'?: object;
    /**
     * Rule modifications, keys are identifiers
     * @type {object}
     * @memberof Profile
     */
    'rules'?: object;
    /**
     * Variables modifications, keys are identifiers
     * @type {object}
     * @memberof Profile
     */
    'variables'?: object;
}
/**
 *
 * @export
 * @interface Profile200Response
 */
export interface Profile200Response {
    /**
     *
     * @type {Profiles200ResponseDataInner}
     * @memberof Profile200Response
     */
    'data'?: Profiles200ResponseDataInner;
}
/**
 *
 * @export
 * @interface ProfileGroupsValue
 */
export interface ProfileGroupsValue {
    [key: string]: any;

    /**
     * Includes or excludes a group of rules from evaluation
     * @type {any}
     * @memberof ProfileGroupsValue
     */
    'evaluate'?: any;
}
/**
 *
 * @export
 * @interface ProfileRulesValue
 */
export interface ProfileRulesValue {
    [key: string]: any;

    /**
     * Includes or excludes a rule from evaluation
     * @type {any}
     * @memberof ProfileRulesValue
     */
    'evaluate'?: any;
    /**
     * Overrides severity level of the rule
     * @type {any}
     * @memberof ProfileRulesValue
     */
    'severity'?: ProfileRulesValueSeverityEnum;
    /**
     * Overrides role of the rule
     * @type {any}
     * @memberof ProfileRulesValue
     */
    'role'?: ProfileRulesValueRoleEnum;
}
/**
 * @type ProfileVariablesValue
 * @export
 */
export type ProfileVariablesValue = any;

/**
 *
 * @export
 * @interface Profiles200Response
 */
export interface Profiles200Response {
    /**
     *
     * @type {Metadata}
     * @memberof Profiles200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof Profiles200Response
     */
    'links'?: Links;
    /**
     *
     * @type {Array<Profiles200ResponseDataInner>}
     * @memberof Profiles200Response
     */
    'data'?: Array<Profiles200ResponseDataInner>;
}
/**
 *
 * @export
 * @interface Profiles200ResponseDataInner
 */
export interface Profiles200ResponseDataInner {
    /**
     *
     * @type {Profile}
     * @memberof Profiles200ResponseDataInner
     */
    'schema'?: Profile;
}
/**
 *
 * @export
 * @interface Rule
 */
export interface Rule {
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof Rule
     */
    'type'?: RuleTypeEnum;
    /**
     * Identificator of the Rule
     * @type {string}
     * @memberof Rule
     */
    'ref_id'?: string;
    /**
     * Short title of the Rule
     * @type {string}
     * @memberof Rule
     */
    'title'?: string;
    /**
     * Rationale of the Rule
     * @type {string}
     * @memberof Rule
     */
    'rationale'?: string;
    /**
     * Longer description of the Rule
     * @type {string}
     * @memberof Rule
     */
    'description'?: string;
    /**
     * The original sorting precedence of the Rule in the Security Guide
     * @type {number}
     * @memberof Rule
     */
    'precedence'?: number;
    /**
     * The severity of the Rule
     * @type {string}
     * @memberof Rule
     */
    'severity'?: string;
    /**
     * The idenfitier of the remediation associated to this rule, only available under profiles.
     * @type {string}
     * @memberof Rule
     */
    'remediation_issue_id'?: string | null;
}

export const RuleTypeEnum = {
    Rule: 'rule'
} as const;

export type RuleTypeEnum = typeof RuleTypeEnum[keyof typeof RuleTypeEnum];

/**
 *
 * @export
 * @interface Rule200Response
 */
export interface Rule200Response {
    /**
     *
     * @type {Rules200ResponseDataInner}
     * @memberof Rule200Response
     */
    'data'?: Rules200ResponseDataInner;
}
/**
 *
 * @export
 * @interface RuleGroup
 */
export interface RuleGroup {
    /**
     *
     * @type {string}
     * @memberof RuleGroup
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof RuleGroup
     */
    'type'?: RuleGroupTypeEnum;
    /**
     * Identificator of the Rule Group
     * @type {string}
     * @memberof RuleGroup
     */
    'ref_id'?: string;
    /**
     * Short title of the Rule Group
     * @type {string}
     * @memberof RuleGroup
     */
    'title'?: string;
    /**
     * Rationale of the Rule Group
     * @type {string}
     * @memberof RuleGroup
     */
    'rationale'?: string;
    /**
     * Longer description of the Rule Group
     * @type {string}
     * @memberof RuleGroup
     */
    'description'?: string;
    /**
     * The original sorting precedence of the Rule Group in the Security Guide
     * @type {number}
     * @memberof RuleGroup
     */
    'precedence'?: number;
}

export const RuleGroupTypeEnum = {
    RuleGroup: 'rule_group'
} as const;

export type RuleGroupTypeEnum = typeof RuleGroupTypeEnum[keyof typeof RuleGroupTypeEnum];

/**
 *
 * @export
 * @interface RuleGroup200Response
 */
export interface RuleGroup200Response {
    /**
     *
     * @type {RuleGroups200ResponseDataInner}
     * @memberof RuleGroup200Response
     */
    'data'?: RuleGroups200ResponseDataInner;
}
/**
 *
 * @export
 * @interface RuleGroups200Response
 */
export interface RuleGroups200Response {
    /**
     *
     * @type {Metadata}
     * @memberof RuleGroups200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof RuleGroups200Response
     */
    'links'?: Links;
    /**
     *
     * @type {Array<RuleGroups200ResponseDataInner>}
     * @memberof RuleGroups200Response
     */
    'data'?: Array<RuleGroups200ResponseDataInner>;
}
/**
 *
 * @export
 * @interface RuleGroups200ResponseDataInner
 */
export interface RuleGroups200ResponseDataInner {
    /**
     *
     * @type {RuleGroup}
     * @memberof RuleGroups200ResponseDataInner
     */
    'schema'?: RuleGroup;
}
/**
 * @type RuleTreeInner
 * @export
 */
export type RuleTreeInner = RuleTreeInnerObject | RuleTreeInnerOneOf1;

/**
 *
 * @export
 * @interface RuleTreeInnerObject
 */
export interface RuleTreeInnerObject {
    /**
     *
     * @type {string}
     * @memberof RuleTreeInnerObject
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof RuleTreeInnerObject
     */
    'type'?: RuleTreeInnerObject;
    /**
     *
     * @type {Array<RuleTreeInner>}
     * @memberof RuleTreeInnerObject
     */
    'children'?: Array<RuleTreeInner>;
}

export const RuleTreeInnerObject = {
    RuleGroup: 'rule_group'
} as const;

export type RuleTreeInnerObject = typeof RuleTreeInnerOneOfTypeEnum[keyof typeof RuleTreeInnerOneOfTypeEnum];

/**
 *
 * @export
 * @interface RuleTreeInnerObject1
 */
export interface RuleTreeInnerObject1 {
    /**
     *
     * @type {string}
     * @memberof RuleTreeInnerObject1
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof RuleTreeInnerObject1
     */
    'type'?: RuleTreeInnerObject1TypeEnum;
}

export const RuleTreeInnerObject1TypeEnum = {
    Rule: 'rule'
} as const;

export type RuleTreeInnerObject1TypeEnum = typeof RuleTreeInnerOneOf1TypeEnum[keyof typeof RuleTreeInnerOneOf1TypeEnum];

/**
 *
 * @export
 * @interface Rules200Response
 */
export interface Rules200Response {
    /**
     *
     * @type {Metadata}
     * @memberof Rules200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof Rules200Response
     */
    'links'?: Links;
    /**
     *
     * @type {Array<Rules200ResponseDataInner>}
     * @memberof Rules200Response
     */
    'data'?: Array<Rules200ResponseDataInner>;
}
/**
 *
 * @export
 * @interface Rules200ResponseDataInner
 */
export interface Rules200ResponseDataInner {
    /**
     *
     * @type {Rule}
     * @memberof Rules200ResponseDataInner
     */
    'schema'?: Rule;
}
/**
 *
 * @export
 * @interface SecurityGuide
 */
export interface SecurityGuide {
    /**
     *
     * @type {string}
     * @memberof SecurityGuide
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof SecurityGuide
     */
    'type'?: SecurityGuideTypeEnum;
    /**
     * Identificator of the Security Guide
     * @type {string}
     * @memberof SecurityGuide
     */
    'ref_id'?: string;
    /**
     * Short title of the Security Guide
     * @type {string}
     * @memberof SecurityGuide
     */
    'title'?: string;
    /**
     * Version of the Security Guide
     * @type {string}
     * @memberof SecurityGuide
     */
    'version'?: string;
    /**
     * Longer description of the Security Guide
     * @type {string}
     * @memberof SecurityGuide
     */
    'description'?: string;
    /**
     * Major version of the Operating System that the Security Guide covers
     * @type {number}
     * @memberof SecurityGuide
     */
    'os_major_version'?: number;
}

export const SecurityGuideTypeEnum = {
    SecurityGuide: 'security_guide'
} as const;

export type SecurityGuideTypeEnum = typeof SecurityGuideTypeEnum[keyof typeof SecurityGuideTypeEnum];

/**
 *
 * @export
 * @interface SecurityGuide200Response
 */
export interface SecurityGuide200Response {
    /**
     *
     * @type {SecurityGuides200ResponseDataInner}
     * @memberof SecurityGuide200Response
     */
    'data'?: SecurityGuides200ResponseDataInner;
}
/**
 *
 * @export
 * @interface SecurityGuides200Response
 */
export interface SecurityGuides200Response {
    /**
     *
     * @type {Metadata}
     * @memberof SecurityGuides200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof SecurityGuides200Response
     */
    'links'?: Links;
    /**
     *
     * @type {Array<SecurityGuides200ResponseDataInner>}
     * @memberof SecurityGuides200Response
     */
    'data'?: Array<SecurityGuides200ResponseDataInner>;
}
/**
 *
 * @export
 * @interface SecurityGuides200ResponseDataInner
 */
export interface SecurityGuides200ResponseDataInner {
    /**
     *
     * @type {SecurityGuide}
     * @memberof SecurityGuides200ResponseDataInner
     */
    'schema'?: SecurityGuide;
}
/**
 *
 * @export
 * @interface SupportedProfile
 */
export interface SupportedProfile {
    /**
     *
     * @type {string}
     * @memberof SupportedProfile
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof SupportedProfile
     */
    'type'?: SupportedProfileTypeEnum;
    /**
     * Identificator of the Profile
     * @type {string}
     * @memberof SupportedProfile
     */
    'ref_id'?: string;
    /**
     * Short title of the Profile
     * @type {string}
     * @memberof SupportedProfile
     */
    'title'?: string;
    /**
     * Version of the latest Security Guide supporting this Profile
     * @type {string}
     * @memberof SupportedProfile
     */
    'security_guide_version'?: string;
    /**
     * Major version of the Operating System that the Profile covers
     * @type {number}
     * @memberof SupportedProfile
     */
    'os_major_version'?: number;
    /**
     * List of the supported Operating System minor versions that the Profile covers
     * @type {Array<number>}
     * @memberof SupportedProfile
     */
    'os_minor_versions'?: Array<number>;
}

export const SupportedProfileTypeEnum = {
    SupportedProfile: 'supported_profile'
} as const;

export type SupportedProfileTypeEnum = typeof SupportedProfileTypeEnum[keyof typeof SupportedProfileTypeEnum];

/**
 *
 * @export
 * @interface SupportedProfiles200Response
 */
export interface SupportedProfiles200Response {
    /**
     *
     * @type {Metadata}
     * @memberof SupportedProfiles200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof SupportedProfiles200Response
     */
    'links'?: Links;
    /**
     *
     * @type {Array<SupportedProfiles200ResponseDataInner>}
     * @memberof SupportedProfiles200Response
     */
    'data'?: Array<SupportedProfiles200ResponseDataInner>;
}
/**
 *
 * @export
 * @interface SupportedProfiles200ResponseDataInner
 */
export interface SupportedProfiles200ResponseDataInner {
    /**
     *
     * @type {SupportedProfile}
     * @memberof SupportedProfiles200ResponseDataInner
     */
    'schema'?: SupportedProfile;
}
/**
 *
 * @export
 * @interface System
 */
export interface System {
    /**
     *
     * @type {string}
     * @memberof System
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof System
     */
    'type'?: SystemTypeEnum;
    /**
     * Display Name of the System
     * @type {string}
     * @memberof System
     */
    'display_name'?: string;
    /**
     *
     * @type {Array<SystemGroupsInner>}
     * @memberof System
     */
    'groups'?: Array<SystemGroupsInner>;
    /**
     *
     * @type {string}
     * @memberof System
     */
    'culled_timestamp'?: string;
    /**
     *
     * @type {string}
     * @memberof System
     */
    'stale_timestamp'?: string;
    /**
     *
     * @type {string}
     * @memberof System
     */
    'stale_warning_timestamp'?: string;
    /**
     *
     * @type {string}
     * @memberof System
     */
    'updated'?: string;
    /**
     *
     * @type {string}
     * @memberof System
     */
    'insights_id'?: string;
    /**
     *
     * @type {Array<SystemTagsInner>}
     * @memberof System
     */
    'tags'?: Array<SystemTagsInner>;
    /**
     * Major version of the Operating System
     * @type {number}
     * @memberof System
     */
    'os_major_version'?: number;
    /**
     * Minor version of the Operating System
     * @type {number}
     * @memberof System
     */
    'os_minor_version'?: number;
    /**
     * List of Policies assigned to the System, visible only when not listing Systems under a given Policy
     * @type {Array<SystemPoliciesInner>}
     * @memberof System
     */
    'policies'?: Array<SystemPoliciesInner>;
}

export const SystemTypeEnum = {
    System: 'system'
} as const;

export type SystemTypeEnum = typeof SystemTypeEnum[keyof typeof SystemTypeEnum];

/**
 *
 * @export
 * @interface System200Response
 */
export interface System200Response {
    /**
     *
     * @type {Systems200ResponseDataInner}
     * @memberof System200Response
     */
    'data'?: Systems200ResponseDataInner;
}
/**
 * List of Inventory Groups the System belongs to
 * @export
 * @interface SystemGroupsInner
 */
export interface SystemGroupsInner {
    /**
     *
     * @type {string}
     * @memberof SystemGroupsInner
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof SystemGroupsInner
     */
    'name'?: string;
}
/**
 *
 * @export
 * @interface SystemPoliciesInner
 */
export interface SystemPoliciesInner {
    /**
     *
     * @type {string}
     * @memberof SystemPoliciesInner
     */
    'id'?: string;
    /**
     * Short title of the Policy
     * @type {string}
     * @memberof SystemPoliciesInner
     */
    'title'?: string;
}
/**
 * List of Tags assigned to the System
 * @export
 * @interface SystemTagsInner
 */
export interface SystemTagsInner {
    /**
     *
     * @type {string}
     * @memberof SystemTagsInner
     */
    'namespace'?: string;
    /**
     *
     * @type {string}
     * @memberof SystemTagsInner
     */
    'key'?: string;
    /**
     *
     * @type {string}
     * @memberof SystemTagsInner
     */
    'value'?: string;
}
/**
 *
 * @export
 * @interface Systems200Response
 */
export interface Systems200Response {
    /**
     *
     * @type {Metadata}
     * @memberof Systems200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof Systems200Response
     */
    'links'?: Links;
    /**
     *
     * @type {Array<Systems200ResponseDataInner>}
     * @memberof Systems200Response
     */
    'data'?: Array<Systems200ResponseDataInner>;
}
/**
 *
 * @export
 * @interface Systems200ResponseDataInner
 */
export interface Systems200ResponseDataInner {
    /**
     *
     * @type {System}
     * @memberof Systems200ResponseDataInner
     */
    'schema'?: System;
}
/**
 *
 * @export
 * @interface Tailoring
 */
export interface Tailoring {
    /**
     *
     * @type {string}
     * @memberof Tailoring
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof Tailoring
     */
    'type'?: TailoringTypeEnum;
    /**
     * Identificator of the Profile from which the Tailoring was cloned
     * @type {string}
     * @memberof Tailoring
     */
    'profile_id'?: string;
    /**
     * Major version of the Operating System that the Tailoring covers
     * @type {number}
     * @memberof Tailoring
     */
    'os_major_version'?: number;
    /**
     * Minor version of the Operating System that the Tailoring covers
     * @type {number}
     * @memberof Tailoring
     */
    'os_minor_version'?: number;
    /**
     * Pair of keys and values for Value Definition customizations
     * @type {object}
     * @memberof Tailoring
     */
    'value_overrides'?: object;
}

export const TailoringTypeEnum = {
    Tailoring: 'tailoring'
} as const;

export type TailoringTypeEnum = typeof TailoringTypeEnum[keyof typeof TailoringTypeEnum];

/**
 *
 * @export
 * @interface Tailoring200Response
 */
export interface Tailoring200Response {
    /**
     *
     * @type {Tailorings200ResponseDataInner}
     * @memberof Tailoring200Response
     */
    'data'?: Tailorings200ResponseDataInner;
}
/**
 * Defines customizations of rules and variables for a set of profiles
 * @export
 * @interface TailoringFile
 */
export interface TailoringFile {
    /**
     *
     * @type {Array<Profile>}
     * @memberof TailoringFile
     */
    'profiles'?: Array<Profile>;
}
/**
 * @type TailoringIdParameter
 * @export
 */
export type TailoringIdParameter = number | string;

/**
 *
 * @export
 * @interface Tailorings200Response
 */
export interface Tailorings200Response {
    /**
     *
     * @type {Metadata}
     * @memberof Tailorings200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof Tailorings200Response
     */
    'links'?: Links;
    /**
     *
     * @type {Array<Tailorings200ResponseDataInner>}
     * @memberof Tailorings200Response
     */
    'data'?: Array<Tailorings200ResponseDataInner>;
}
/**
 *
 * @export
 * @interface Tailorings200ResponseDataInner
 */
export interface Tailorings200ResponseDataInner {
    /**
     *
     * @type {Tailoring}
     * @memberof Tailorings200ResponseDataInner
     */
    'schema'?: Tailoring;
}
/**
 *
 * @export
 * @interface ValueDefinition
 */
export interface ValueDefinition {
    /**
     *
     * @type {string}
     * @memberof ValueDefinition
     */
    'id'?: string;
    /**
     *
     * @type {string}
     * @memberof ValueDefinition
     */
    'type'?: ValueDefinitionTypeEnum;
    /**
     * Identificator of the Value Definition
     * @type {string}
     * @memberof ValueDefinition
     */
    'ref_id'?: string;
    /**
     * Short title of the Value Definition
     * @type {string}
     * @memberof ValueDefinition
     */
    'title'?: string;
    /**
     * Type of the Value Definition
     * @type {string}
     * @memberof ValueDefinition
     */
    'value_type'?: string;
    /**
     * Longer description of the Value Definition
     * @type {string}
     * @memberof ValueDefinition
     */
    'description'?: string;
    /**
     * Default value of the Value Definition
     * @type {string}
     * @memberof ValueDefinition
     */
    'default_value'?: string;
}

export const ValueDefinitionTypeEnum = {
    ValueDefinition: 'value_definition'
} as const;

export type ValueDefinitionTypeEnum = typeof ValueDefinitionTypeEnum[keyof typeof ValueDefinitionTypeEnum];

/**
 *
 * @export
 * @interface ValueDefinition200Response
 */
export interface ValueDefinition200Response {
    /**
     *
     * @type {ValueDefinitions200ResponseDataInner}
     * @memberof ValueDefinition200Response
     */
    'data'?: ValueDefinitions200ResponseDataInner;
}
/**
 *
 * @export
 * @interface ValueDefinitions200Response
 */
export interface ValueDefinitions200Response {
    /**
     *
     * @type {Metadata}
     * @memberof ValueDefinitions200Response
     */
    'meta'?: Metadata;
    /**
     *
     * @type {Links}
     * @memberof ValueDefinitions200Response
     */
    'links'?: Links;
    /**
     *
     * @type {Array<ValueDefinitions200ResponseDataInner>}
     * @memberof ValueDefinitions200Response
     */
    'data'?: Array<ValueDefinitions200ResponseDataInner>;
}
/**
 *
 * @export
 * @interface ValueDefinitions200ResponseDataInner
 */
export interface ValueDefinitions200ResponseDataInner {
    /**
     *
     * @type {ValueDefinition}
     * @memberof ValueDefinitions200ResponseDataInner
     */
    'schema'?: ValueDefinition;
}

/**
 * ContentApi - axios parameter creator
 * @export
 */
export const ContentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a Profile
         * @summary Request a Profile
         * @param {string} securityGuideId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile: async (securityGuideId: string, id: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profile', 'securityGuideId', securityGuideId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profile', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/profiles/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Rule assigned to a Profile
         * @summary Request a Rule assigned to a Profile
         * @param {string} securityGuideId
         * @param {string} profileId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRule: async (securityGuideId: string, profileId: string, id: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profileRule', 'securityGuideId', securityGuideId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('profileRule', 'profileId', profileId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('profileRule', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/profiles/{profile_id}/rules/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Rules assigned to a Profile
         * @summary Request Rules assigned to a Profile
         * @param {string} securityGuideId
         * @param {string} profileId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<ProfileRulesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRules: async (securityGuideId: string, profileId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<ProfileRulesSortByEnum>, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profileRules', 'securityGuideId', securityGuideId)
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('profileRules', 'profileId', profileId)
            const localVarPath = `/security_guides/{security_guide_id}/profiles/{profile_id}/rules`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Profiles
         * @summary Request Profiles
         * @param {string} securityGuideId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<ProfilesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profiles: async (securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<ProfilesSortByEnum>, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('profiles', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/profiles`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Rule
         * @summary Request a Rule
         * @param {string} securityGuideId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rule: async (securityGuideId: string, id: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('rule', 'securityGuideId', securityGuideId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rule', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/rules/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Rule Group
         * @summary Request a Rule Group
         * @param {string} securityGuideId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroup: async (securityGuideId: string, id: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('ruleGroup', 'securityGuideId', securityGuideId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ruleGroup', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/rule_groups/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Rule Groups
         * @summary Request Rule Groups
         * @param {string} securityGuideId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<RuleGroupsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroups: async (securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<RuleGroupsSortByEnum>, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('ruleGroups', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/rule_groups`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Rules assigned
         * @summary Request Rules
         * @param {string} securityGuideId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<RulesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rules: async (securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<RulesSortByEnum>, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('rules', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/rules`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Security Guide
         * @summary Request a Security Guide
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuide: async (id: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGuide', 'id', id)
            const localVarPath = `/security_guides/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the Rule Tree of a Security Guide
         * @summary Request the Rule Tree of a Security Guide
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuideRuleTree: async (id: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGuideRuleTree', 'id', id)
            const localVarPath = `/security_guides/{id}/rule_tree`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Security Guides
         * @summary Request Security Guides
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<SecurityGuidesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuides: async (xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SecurityGuidesSortByEnum>, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/security_guides`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Supported Profiles
         * @summary Request Supported Profiles
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<SupportedProfilesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportedProfiles: async (xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SupportedProfilesSortByEnum>, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/security_guides/supported_profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Value Definition
         * @summary Request a Value Definition
         * @param {string} securityGuideId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinition: async (securityGuideId: string, id: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('valueDefinition', 'securityGuideId', securityGuideId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('valueDefinition', 'id', id)
            const localVarPath = `/security_guides/{security_guide_id}/value_definitions/{id}`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Value Definitions
         * @summary Request Value Definitions
         * @param {string} securityGuideId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<ValueDefinitionsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinitions: async (securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<ValueDefinitionsSortByEnum>, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGuideId' is not null or undefined
            assertParamExists('valueDefinitions', 'securityGuideId', securityGuideId)
            const localVarPath = `/security_guides/{security_guide_id}/value_definitions`
                .replace(`{${"security_guide_id"}}`, encodeURIComponent(String(securityGuideId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContentApi - functional programming interface
 * @export
 */
export const ContentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContentApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a Profile
         * @summary Request a Profile
         * @param {string} securityGuideId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profile(securityGuideId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profile200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profile(securityGuideId, id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.profile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a Rule assigned to a Profile
         * @summary Request a Rule assigned to a Profile
         * @param {string} securityGuideId
         * @param {string} profileId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileRule(securityGuideId: string, profileId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileRule(securityGuideId, profileId, id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.profileRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists Rules assigned to a Profile
         * @summary Request Rules assigned to a Profile
         * @param {string} securityGuideId
         * @param {string} profileId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<ProfileRulesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profileRules(securityGuideId: string, profileId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<ProfileRulesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profileRules(securityGuideId, profileId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.profileRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists Profiles
         * @summary Request Profiles
         * @param {string} securityGuideId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<ProfilesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async profiles(securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<ProfilesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Profiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.profiles(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.profiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a Rule
         * @summary Request a Rule
         * @param {string} securityGuideId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rule(securityGuideId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rule200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rule(securityGuideId, id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.rule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a Rule Group
         * @summary Request a Rule Group
         * @param {string} securityGuideId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleGroup(securityGuideId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroup200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleGroup(securityGuideId, id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.ruleGroup']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists Rule Groups
         * @summary Request Rule Groups
         * @param {string} securityGuideId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<RuleGroupsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ruleGroups(securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<RuleGroupsSortByEnum>, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RuleGroups200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ruleGroups(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.ruleGroups']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists Rules assigned
         * @summary Request Rules
         * @param {string} securityGuideId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<RulesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rules(securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<RulesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rules(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.rules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a Security Guide
         * @summary Request a Security Guide
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGuide(id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGuide200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGuide(id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.securityGuide']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the Rule Tree of a Security Guide
         * @summary Request the Rule Tree of a Security Guide
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGuideRuleTree(id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RuleTreeInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGuideRuleTree(id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.securityGuideRuleTree']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists Security Guides
         * @summary Request Security Guides
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<SecurityGuidesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGuides(xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SecurityGuidesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGuides200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGuides(xRHIDENTITY, limit, offset, sortBy, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.securityGuides']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists Supported Profiles
         * @summary Request Supported Profiles
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<SupportedProfilesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportedProfiles(xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SupportedProfilesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportedProfiles200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportedProfiles(xRHIDENTITY, limit, offset, sortBy, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.supportedProfiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a Value Definition
         * @summary Request a Value Definition
         * @param {string} securityGuideId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async valueDefinition(securityGuideId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueDefinition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.valueDefinition(securityGuideId, id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.valueDefinition']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists Value Definitions
         * @summary Request Value Definitions
         * @param {string} securityGuideId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<ValueDefinitionsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async valueDefinitions(securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<ValueDefinitionsSortByEnum>, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValueDefinitions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.valueDefinitions(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ContentApi.valueDefinitions']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ContentApi - factory interface
 * @export
 */
export const ContentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContentApiFp(configuration)
    return {
        /**
         * Returns a Profile
         * @summary Request a Profile
         * @param {string} securityGuideId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profile(securityGuideId: string, id: string, xRHIDENTITY?: string, options?: any): AxiosPromise<Profile200Response> {
            return localVarFp.profile(securityGuideId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Rule assigned to a Profile
         * @summary Request a Rule assigned to a Profile
         * @param {string} securityGuideId
         * @param {string} profileId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRule(securityGuideId: string, profileId: string, id: string, xRHIDENTITY?: string, options?: any): AxiosPromise<Rule200Response> {
            return localVarFp.profileRule(securityGuideId, profileId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Rules assigned to a Profile
         * @summary Request Rules assigned to a Profile
         * @param {string} securityGuideId
         * @param {string} profileId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<ProfileRulesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profileRules(securityGuideId: string, profileId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<ProfileRulesSortByEnum>, filter?: string, options?: any): AxiosPromise<Rules200Response> {
            return localVarFp.profileRules(securityGuideId, profileId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Profiles
         * @summary Request Profiles
         * @param {string} securityGuideId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<ProfilesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        profiles(securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<ProfilesSortByEnum>, filter?: string, options?: any): AxiosPromise<Profiles200Response> {
            return localVarFp.profiles(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Rule
         * @summary Request a Rule
         * @param {string} securityGuideId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rule(securityGuideId: string, id: string, xRHIDENTITY?: string, options?: any): AxiosPromise<Rule200Response> {
            return localVarFp.rule(securityGuideId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Rule Group
         * @summary Request a Rule Group
         * @param {string} securityGuideId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroup(securityGuideId: string, id: string, xRHIDENTITY?: string, options?: any): AxiosPromise<RuleGroup200Response> {
            return localVarFp.ruleGroup(securityGuideId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Rule Groups
         * @summary Request Rule Groups
         * @param {string} securityGuideId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<RuleGroupsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ruleGroups(securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<RuleGroupsSortByEnum>, filter?: string, options?: any): AxiosPromise<RuleGroups200Response> {
            return localVarFp.ruleGroups(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Rules assigned
         * @summary Request Rules
         * @param {string} securityGuideId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<RulesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rules(securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<RulesSortByEnum>, filter?: string, options?: any): AxiosPromise<Rules200Response> {
            return localVarFp.rules(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Security Guide
         * @summary Request a Security Guide
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuide(id: string, xRHIDENTITY?: string, options?: any): AxiosPromise<SecurityGuide200Response> {
            return localVarFp.securityGuide(id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the Rule Tree of a Security Guide
         * @summary Request the Rule Tree of a Security Guide
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuideRuleTree(id: string, xRHIDENTITY?: string, options?: any): AxiosPromise<Array<RuleTreeInner>> {
            return localVarFp.securityGuideRuleTree(id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Security Guides
         * @summary Request Security Guides
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<SecurityGuidesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGuides(xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SecurityGuidesSortByEnum>, filter?: string, options?: any): AxiosPromise<SecurityGuides200Response> {
            return localVarFp.securityGuides(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Supported Profiles
         * @summary Request Supported Profiles
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<SupportedProfilesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportedProfiles(xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SupportedProfilesSortByEnum>, filter?: string, options?: any): AxiosPromise<SupportedProfiles200Response> {
            return localVarFp.supportedProfiles(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Value Definition
         * @summary Request a Value Definition
         * @param {string} securityGuideId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinition(securityGuideId: string, id: string, xRHIDENTITY?: string, options?: any): AxiosPromise<ValueDefinition200Response> {
            return localVarFp.valueDefinition(securityGuideId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Value Definitions
         * @summary Request Value Definitions
         * @param {string} securityGuideId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<ValueDefinitionsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        valueDefinitions(securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<ValueDefinitionsSortByEnum>, filter?: string, options?: any): AxiosPromise<ValueDefinitions200Response> {
            return localVarFp.valueDefinitions(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContentApi - object-oriented interface
 * @export
 * @class ContentApi
 * @extends {BaseAPI}
 */
export class ContentApi extends BaseAPI {
    /**
     * Returns a Profile
     * @summary Request a Profile
     * @param {string} securityGuideId
     * @param {string} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public profile(securityGuideId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).profile(securityGuideId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Rule assigned to a Profile
     * @summary Request a Rule assigned to a Profile
     * @param {string} securityGuideId
     * @param {string} profileId
     * @param {string} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public profileRule(securityGuideId: string, profileId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).profileRule(securityGuideId, profileId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Rules assigned to a Profile
     * @summary Request Rules assigned to a Profile
     * @param {string} securityGuideId
     * @param {string} profileId
     * @param {string} [xRHIDENTITY]
     * @param {number} [limit] Number of items to return per page
     * @param {number} [offset] Offset of first item of paginated response
     * @param {Array<ProfileRulesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public profileRules(securityGuideId: string, profileId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<ProfileRulesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).profileRules(securityGuideId, profileId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Profiles
     * @summary Request Profiles
     * @param {string} securityGuideId
     * @param {string} [xRHIDENTITY]
     * @param {number} [limit] Number of items to return per page
     * @param {number} [offset] Offset of first item of paginated response
     * @param {Array<ProfilesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Profiles are searchable using attributes &#x60;title&#x60; and &#x60;ref_id&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public profiles(securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<ProfilesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).profiles(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Rule
     * @summary Request a Rule
     * @param {string} securityGuideId
     * @param {string} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public rule(securityGuideId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).rule(securityGuideId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Rule Group
     * @summary Request a Rule Group
     * @param {string} securityGuideId
     * @param {string} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public ruleGroup(securityGuideId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).ruleGroup(securityGuideId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Rule Groups
     * @summary Request Rule Groups
     * @param {string} securityGuideId
     * @param {string} [xRHIDENTITY]
     * @param {number} [limit] Number of items to return per page
     * @param {number} [offset] Offset of first item of paginated response
     * @param {Array<RuleGroupsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rule Groups are searchable using attributes &lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public ruleGroups(securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<RuleGroupsSortByEnum>, filter?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).ruleGroups(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Rules assigned
     * @summary Request Rules
     * @param {string} securityGuideId
     * @param {string} [xRHIDENTITY]
     * @param {number} [limit] Number of items to return per page
     * @param {number} [offset] Offset of first item of paginated response
     * @param {Array<RulesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public rules(securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<RulesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).rules(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Security Guide
     * @summary Request a Security Guide
     * @param {string} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public securityGuide(id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).securityGuide(id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the Rule Tree of a Security Guide
     * @summary Request the Rule Tree of a Security Guide
     * @param {string} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public securityGuideRuleTree(id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).securityGuideRuleTree(id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Security Guides
     * @summary Request Security Guides
     * @param {string} [xRHIDENTITY]
     * @param {number} [limit] Number of items to return per page
     * @param {number} [offset] Offset of first item of paginated response
     * @param {Array<SecurityGuidesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Security Guides are searchable using attributes &#x60;title&#x60;, &#x60;version&#x60;, &#x60;ref_id&#x60;, and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public securityGuides(xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SecurityGuidesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).securityGuides(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Supported Profiles
     * @summary Request Supported Profiles
     * @param {string} [xRHIDENTITY]
     * @param {number} [limit] Number of items to return per page
     * @param {number} [offset] Offset of first item of paginated response
     * @param {Array<SupportedProfilesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Supported Profiles are searchable using attributes &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public supportedProfiles(xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SupportedProfilesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).supportedProfiles(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Value Definition
     * @summary Request a Value Definition
     * @param {string} securityGuideId
     * @param {string} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public valueDefinition(securityGuideId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).valueDefinition(securityGuideId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Value Definitions
     * @summary Request Value Definitions
     * @param {string} securityGuideId
     * @param {string} [xRHIDENTITY]
     * @param {number} [limit] Number of items to return per page
     * @param {number} [offset] Offset of first item of paginated response
     * @param {Array<ValueDefinitionsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Value Definitions are searchable using attributes &#x60;title&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContentApi
     */
    public valueDefinitions(securityGuideId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<ValueDefinitionsSortByEnum>, filter?: string, options?: RawAxiosRequestConfig) {
        return ContentApiFp(this.configuration).valueDefinitions(securityGuideId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ProfileRulesSortByEnum = {
    Title: 'title',
    Severity: 'severity',
    Precedence: 'precedence',
    Titleasc: 'title:asc',
    Titledesc: 'title:desc',
    Severityasc: 'severity:asc',
    Severitydesc: 'severity:desc',
    Precedenceasc: 'precedence:asc',
    Precedencedesc: 'precedence:desc'
} as const;
export type ProfileRulesSortByEnum = typeof ProfileRulesSortByEnum[keyof typeof ProfileRulesSortByEnum];
/**
 * @export
 */
export const ProfilesSortByEnum = {
    Title: 'title',
    Titleasc: 'title:asc',
    Titledesc: 'title:desc'
} as const;
export type ProfilesSortByEnum = typeof ProfilesSortByEnum[keyof typeof ProfilesSortByEnum];
/**
 * @export
 */
export const RuleGroupsSortByEnum = {
    Precedence: 'precedence',
    Precedenceasc: 'precedence:asc',
    Precedencedesc: 'precedence:desc'
} as const;
export type RuleGroupsSortByEnum = typeof RuleGroupsSortByEnum[keyof typeof RuleGroupsSortByEnum];
/**
 * @export
 */
export const RulesSortByEnum = {
    Title: 'title',
    Severity: 'severity',
    Precedence: 'precedence',
    Titleasc: 'title:asc',
    Titledesc: 'title:desc',
    Severityasc: 'severity:asc',
    Severitydesc: 'severity:desc',
    Precedenceasc: 'precedence:asc',
    Precedencedesc: 'precedence:desc'
} as const;
export type RulesSortByEnum = typeof RulesSortByEnum[keyof typeof RulesSortByEnum];
/**
 * @export
 */
export const SecurityGuidesSortByEnum = {
    Title: 'title',
    Version: 'version',
    OsMajorVersion: 'os_major_version',
    Titleasc: 'title:asc',
    Titledesc: 'title:desc',
    Versionasc: 'version:asc',
    Versiondesc: 'version:desc',
    OsMajorVersionasc: 'os_major_version:asc',
    OsMajorVersiondesc: 'os_major_version:desc'
} as const;
export type SecurityGuidesSortByEnum = typeof SecurityGuidesSortByEnum[keyof typeof SecurityGuidesSortByEnum];
/**
 * @export
 */
export const SupportedProfilesSortByEnum = {
    Title: 'title',
    OsMajorVersion: 'os_major_version',
    OsMinorVersions: 'os_minor_versions',
    Titleasc: 'title:asc',
    Titledesc: 'title:desc',
    OsMajorVersionasc: 'os_major_version:asc',
    OsMajorVersiondesc: 'os_major_version:desc',
    OsMinorVersionsasc: 'os_minor_versions:asc',
    OsMinorVersionsdesc: 'os_minor_versions:desc'
} as const;
export type SupportedProfilesSortByEnum = typeof SupportedProfilesSortByEnum[keyof typeof SupportedProfilesSortByEnum];
/**
 * @export
 */
export const ValueDefinitionsSortByEnum = {
    Title: 'title',
    Titleasc: 'title:asc',
    Titledesc: 'title:desc'
} as const;
export type ValueDefinitionsSortByEnum = typeof ValueDefinitionsSortByEnum[keyof typeof ValueDefinitionsSortByEnum];


/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns a Rule to a Tailoring
         * @summary Assign a Rule to a Tailoring
         * @param {string} policyId
         * @param {string} tailoringId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRule: async (policyId: string, tailoringId: string, id: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignRule', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('assignRule', 'tailoringId', tailoringId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assignRule', 'id', id)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Rules to a Tailoring
         * @param {string} policyId
         * @param {string} tailoringId
         * @param {string} [xRHIDENTITY]
         * @param {AssignRulesRequest} [assignRulesRequest]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignRules: async (policyId: string, tailoringId: string, xRHIDENTITY?: string, assignRulesRequest?: AssignRulesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignRules', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('assignRules', 'tailoringId', tailoringId)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assigns a System to a Policy
         * @summary Assign a System to a Policy
         * @param {string} id
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignSystem: async (id: string, policyId: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('assignSystem', 'id', id)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignSystem', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Systems to a Policy
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {AssignRulesRequest} [assignRulesRequest]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignSystems: async (policyId: string, xRHIDENTITY?: string, assignRulesRequest?: AssignRulesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('assignSystems', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Policy with the provided attributes
         * @summary Create a Policy
         * @param {string} [xRHIDENTITY]
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy: async (xRHIDENTITY?: string, policy?: Policy, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policy, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Policy
         * @summary Delete a Policy
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy: async (id: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePolicy', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Policies
         * @summary Request Policies
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<PoliciesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policies: async (xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<PoliciesSortByEnum>, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Policy
         * @summary Request a Policy
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policy: async (id: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('policy', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Systems assigned to a Policy
         * @summary Request Systems assigned to a Policy
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<PolicySystemsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policySystems: async (policyId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<PolicySystemsSortByEnum>, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policySystems', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Tailoring
         * @summary Request a Tailoring
         * @param {string} policyId
         * @param {TailoringIdParameter} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoring: async (policyId: string, id: TailoringIdParameter, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailoring', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tailoring', 'id', id)
            const localVarPath = `/policies/{policy_id}/tailorings/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Tailoring File
         * @summary Request a Tailoring file
         * @param {string} policyId
         * @param {TailoringIdParameter} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringFile: async (policyId: string, id: TailoringIdParameter, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailoringFile', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tailoringFile', 'id', id)
            const localVarPath = `/policies/{policy_id}/tailorings/{id}/tailoring_file.json`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Rules assigned to a Tailoring
         * @summary Request Rules assigned to a Tailoring
         * @param {string} policyId
         * @param {string} tailoringId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<TailoringRulesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringRules: async (policyId: string, tailoringId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<TailoringRulesSortByEnum>, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailoringRules', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('tailoringRules', 'tailoringId', tailoringId)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Tailorings
         * @summary Request Tailorings
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<TailoringsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailorings: async (policyId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<TailoringsSortByEnum>, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('tailorings', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/tailorings`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unassigns a Rule from a Tailoring
         * @summary Unassign a Rule from a Tailoring
         * @param {string} policyId
         * @param {string} tailoringId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignRule: async (policyId: string, tailoringId: string, id: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('unassignRule', 'policyId', policyId)
            // verify required parameter 'tailoringId' is not null or undefined
            assertParamExists('unassignRule', 'tailoringId', tailoringId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unassignRule', 'id', id)
            const localVarPath = `/policies/{policy_id}/tailorings/{tailoring_id}/rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tailoring_id"}}`, encodeURIComponent(String(tailoringId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unassigns a System from a Policy
         * @summary Unassign a System from a Policy
         * @param {string} id
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignSystem: async (id: string, policyId: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unassignSystem', 'id', id)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('unassignSystem', 'policyId', policyId)
            const localVarPath = `/policies/{policy_id}/systems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Policy with the provided attributes
         * @summary Update a Policy
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {PolicyUpdate} [policyUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy: async (id: string, xRHIDENTITY?: string, policyUpdate?: PolicyUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePolicy', 'id', id)
            const localVarPath = `/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            localVarHeaderParameter['Content-Type'] = 'application/vnd.api+json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * Assigns a Rule to a Tailoring
         * @summary Assign a Rule to a Tailoring
         * @param {string} policyId
         * @param {string} tailoringId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignRule(policyId: string, tailoringId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignRule(policyId, tailoringId, id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.assignRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Rules to a Tailoring
         * @param {string} policyId
         * @param {string} tailoringId
         * @param {string} [xRHIDENTITY]
         * @param {AssignRulesRequest} [assignRulesRequest]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async assignRules(policyId: string, tailoringId: string, xRHIDENTITY?: string, assignRulesRequest?: AssignRulesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignRules(policyId, tailoringId, xRHIDENTITY, assignRulesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.assignRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assigns a System to a Policy
         * @summary Assign a System to a Policy
         * @param {string} id
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignSystem(id: string, policyId: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignSystem(id, policyId, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.assignSystem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Systems to a Policy
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {AssignRulesRequest} [assignRulesRequest]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async assignSystems(policyId: string, xRHIDENTITY?: string, assignRulesRequest?: AssignRulesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Systems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignSystems(policyId, xRHIDENTITY, assignRulesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.assignSystems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Policy with the provided attributes
         * @summary Create a Policy
         * @param {string} [xRHIDENTITY]
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPolicy(xRHIDENTITY?: string, policy?: Policy, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPolicy(xRHIDENTITY, policy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.createPolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a Policy
         * @summary Delete a Policy
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePolicy(id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePolicy(id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.deletePolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists Policies
         * @summary Request Policies
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<PoliciesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policies(xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<PoliciesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policies(xRHIDENTITY, limit, offset, sortBy, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.policies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a Policy
         * @summary Request a Policy
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policy(id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policy(id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.policy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists Systems assigned to a Policy
         * @summary Request Systems assigned to a Policy
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<PolicySystemsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policySystems(policyId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<PolicySystemsSortByEnum>, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Systems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policySystems(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.policySystems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a Tailoring
         * @summary Request a Tailoring
         * @param {string} policyId
         * @param {TailoringIdParameter} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailoring(policyId: string, id: TailoringIdParameter, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tailoring200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailoring(policyId, id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.tailoring']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a Tailoring File
         * @summary Request a Tailoring file
         * @param {string} policyId
         * @param {TailoringIdParameter} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailoringFile(policyId: string, id: TailoringIdParameter, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TailoringFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailoringFile(policyId, id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.tailoringFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists Rules assigned to a Tailoring
         * @summary Request Rules assigned to a Tailoring
         * @param {string} policyId
         * @param {string} tailoringId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<TailoringRulesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailoringRules(policyId: string, tailoringId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<TailoringRulesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rules200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailoringRules(policyId, tailoringId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.tailoringRules']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists Tailorings
         * @summary Request Tailorings
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<TailoringsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tailorings(policyId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<TailoringsSortByEnum>, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tailorings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tailorings(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.tailorings']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unassigns a Rule from a Tailoring
         * @summary Unassign a Rule from a Tailoring
         * @param {string} policyId
         * @param {string} tailoringId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unassignRule(policyId: string, tailoringId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unassignRule(policyId, tailoringId, id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.unassignRule']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unassigns a System from a Policy
         * @summary Unassign a System from a Policy
         * @param {string} id
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unassignSystem(id: string, policyId: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unassignSystem(id, policyId, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.unassignSystem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a Policy with the provided attributes
         * @summary Update a Policy
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {PolicyUpdate} [policyUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePolicy(id: string, xRHIDENTITY?: string, policyUpdate?: PolicyUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePolicy201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePolicy(id, xRHIDENTITY, policyUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PoliciesApi.updatePolicy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * Assigns a Rule to a Tailoring
         * @summary Assign a Rule to a Tailoring
         * @param {string} policyId
         * @param {string} tailoringId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignRule(policyId: string, tailoringId: string, id: string, xRHIDENTITY?: string, options?: any): AxiosPromise<void> {
            return localVarFp.assignRule(policyId, tailoringId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Rules to a Tailoring
         * @param {string} policyId
         * @param {string} tailoringId
         * @param {string} [xRHIDENTITY]
         * @param {AssignRulesRequest} [assignRulesRequest]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignRules(policyId: string, tailoringId: string, xRHIDENTITY?: string, assignRulesRequest?: AssignRulesRequest, options?: any): AxiosPromise<Rules200Response> {
            return localVarFp.assignRules(policyId, tailoringId, xRHIDENTITY, assignRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Assigns a System to a Policy
         * @summary Assign a System to a Policy
         * @param {string} id
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignSystem(id: string, policyId: string, xRHIDENTITY?: string, options?: any): AxiosPromise<System200Response> {
            return localVarFp.assignSystem(id, policyId, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * This feature is exclusively used by the frontend
         * @summary Bulk assign Systems to a Policy
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {AssignRulesRequest} [assignRulesRequest]
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        assignSystems(policyId: string, xRHIDENTITY?: string, assignRulesRequest?: AssignRulesRequest, options?: any): AxiosPromise<Systems200Response> {
            return localVarFp.assignSystems(policyId, xRHIDENTITY, assignRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Policy with the provided attributes
         * @summary Create a Policy
         * @param {string} [xRHIDENTITY]
         * @param {Policy} [policy]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPolicy(xRHIDENTITY?: string, policy?: Policy, options?: any): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.createPolicy(xRHIDENTITY, policy, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a Policy
         * @summary Delete a Policy
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePolicy(id: string, xRHIDENTITY?: string, options?: any): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.deletePolicy(id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Policies
         * @summary Request Policies
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<PoliciesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policies(xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<PoliciesSortByEnum>, filter?: string, options?: any): AxiosPromise<Policies200Response> {
            return localVarFp.policies(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Policy
         * @summary Request a Policy
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policy(id: string, xRHIDENTITY?: string, options?: any): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.policy(id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Systems assigned to a Policy
         * @summary Request Systems assigned to a Policy
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<PolicySystemsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policySystems(policyId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<PolicySystemsSortByEnum>, filter?: string, options?: any): AxiosPromise<Systems200Response> {
            return localVarFp.policySystems(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Tailoring
         * @summary Request a Tailoring
         * @param {string} policyId
         * @param {TailoringIdParameter} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoring(policyId: string, id: TailoringIdParameter, xRHIDENTITY?: string, options?: any): AxiosPromise<Tailoring200Response> {
            return localVarFp.tailoring(policyId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a Tailoring File
         * @summary Request a Tailoring file
         * @param {string} policyId
         * @param {TailoringIdParameter} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringFile(policyId: string, id: TailoringIdParameter, xRHIDENTITY?: string, options?: any): AxiosPromise<TailoringFile> {
            return localVarFp.tailoringFile(policyId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Rules assigned to a Tailoring
         * @summary Request Rules assigned to a Tailoring
         * @param {string} policyId
         * @param {string} tailoringId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<TailoringRulesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailoringRules(policyId: string, tailoringId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<TailoringRulesSortByEnum>, filter?: string, options?: any): AxiosPromise<Rules200Response> {
            return localVarFp.tailoringRules(policyId, tailoringId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Tailorings
         * @summary Request Tailorings
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<TailoringsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tailorings(policyId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<TailoringsSortByEnum>, filter?: string, options?: any): AxiosPromise<Tailorings200Response> {
            return localVarFp.tailorings(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Unassigns a Rule from a Tailoring
         * @summary Unassign a Rule from a Tailoring
         * @param {string} policyId
         * @param {string} tailoringId
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignRule(policyId: string, tailoringId: string, id: string, xRHIDENTITY?: string, options?: any): AxiosPromise<void> {
            return localVarFp.unassignRule(policyId, tailoringId, id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Unassigns a System from a Policy
         * @summary Unassign a System from a Policy
         * @param {string} id
         * @param {string} policyId
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unassignSystem(id: string, policyId: string, xRHIDENTITY?: string, options?: any): AxiosPromise<System200Response> {
            return localVarFp.unassignSystem(id, policyId, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a Policy with the provided attributes
         * @summary Update a Policy
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {PolicyUpdate} [policyUpdate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePolicy(id: string, xRHIDENTITY?: string, policyUpdate?: PolicyUpdate, options?: any): AxiosPromise<CreatePolicy201Response> {
            return localVarFp.updatePolicy(id, xRHIDENTITY, policyUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * Assigns a Rule to a Tailoring
     * @summary Assign a Rule to a Tailoring
     * @param {string} policyId
     * @param {string} tailoringId
     * @param {string} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public assignRule(policyId: string, tailoringId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).assignRule(policyId, tailoringId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This feature is exclusively used by the frontend
     * @summary Bulk assign Rules to a Tailoring
     * @param {string} policyId
     * @param {string} tailoringId
     * @param {string} [xRHIDENTITY]
     * @param {AssignRulesRequest} [assignRulesRequest]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public assignRules(policyId: string, tailoringId: string, xRHIDENTITY?: string, assignRulesRequest?: AssignRulesRequest, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).assignRules(policyId, tailoringId, xRHIDENTITY, assignRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assigns a System to a Policy
     * @summary Assign a System to a Policy
     * @param {string} id
     * @param {string} policyId
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public assignSystem(id: string, policyId: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).assignSystem(id, policyId, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This feature is exclusively used by the frontend
     * @summary Bulk assign Systems to a Policy
     * @param {string} policyId
     * @param {string} [xRHIDENTITY]
     * @param {AssignRulesRequest} [assignRulesRequest]
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public assignSystems(policyId: string, xRHIDENTITY?: string, assignRulesRequest?: AssignRulesRequest, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).assignSystems(policyId, xRHIDENTITY, assignRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Policy with the provided attributes
     * @summary Create a Policy
     * @param {string} [xRHIDENTITY]
     * @param {Policy} [policy]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public createPolicy(xRHIDENTITY?: string, policy?: Policy, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).createPolicy(xRHIDENTITY, policy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a Policy
     * @summary Delete a Policy
     * @param {string} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public deletePolicy(id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).deletePolicy(id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Policies
     * @summary Request Policies
     * @param {string} [xRHIDENTITY]
     * @param {number} [limit] Number of items to return per page
     * @param {number} [offset] Offset of first item of paginated response
     * @param {Array<PoliciesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policies(xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<PoliciesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policies(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Policy
     * @summary Request a Policy
     * @param {string} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policy(id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policy(id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Systems assigned to a Policy
     * @summary Request Systems assigned to a Policy
     * @param {string} policyId
     * @param {string} [xRHIDENTITY]
     * @param {number} [limit] Number of items to return per page
     * @param {number} [offset] Offset of first item of paginated response
     * @param {Array<PolicySystemsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policySystems(policyId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<PolicySystemsSortByEnum>, filter?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policySystems(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Tailoring
     * @summary Request a Tailoring
     * @param {string} policyId
     * @param {TailoringIdParameter} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public tailoring(policyId: string, id: TailoringIdParameter, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).tailoring(policyId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a Tailoring File
     * @summary Request a Tailoring file
     * @param {string} policyId
     * @param {TailoringIdParameter} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public tailoringFile(policyId: string, id: TailoringIdParameter, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).tailoringFile(policyId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Rules assigned to a Tailoring
     * @summary Request Rules assigned to a Tailoring
     * @param {string} policyId
     * @param {string} tailoringId
     * @param {string} [xRHIDENTITY]
     * @param {number} [limit] Number of items to return per page
     * @param {number} [offset] Offset of first item of paginated response
     * @param {Array<TailoringRulesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Rules are searchable using attributes &#x60;title&#x60; and &#x60;severity&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public tailoringRules(policyId: string, tailoringId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<TailoringRulesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).tailoringRules(policyId, tailoringId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Tailorings
     * @summary Request Tailorings
     * @param {string} policyId
     * @param {string} [xRHIDENTITY]
     * @param {number} [limit] Number of items to return per page
     * @param {number} [offset] Offset of first item of paginated response
     * @param {Array<TailoringsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Tailorings are searchable using attributes &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public tailorings(policyId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<TailoringsSortByEnum>, filter?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).tailorings(policyId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unassigns a Rule from a Tailoring
     * @summary Unassign a Rule from a Tailoring
     * @param {string} policyId
     * @param {string} tailoringId
     * @param {string} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public unassignRule(policyId: string, tailoringId: string, id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).unassignRule(policyId, tailoringId, id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unassigns a System from a Policy
     * @summary Unassign a System from a Policy
     * @param {string} id
     * @param {string} policyId
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public unassignSystem(id: string, policyId: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).unassignSystem(id, policyId, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a Policy with the provided attributes
     * @summary Update a Policy
     * @param {string} id
     * @param {string} [xRHIDENTITY]
     * @param {PolicyUpdate} [policyUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public updatePolicy(id: string, xRHIDENTITY?: string, policyUpdate?: PolicyUpdate, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).updatePolicy(id, xRHIDENTITY, policyUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PoliciesSortByEnum = {
    Title: 'title',
    OsMajorVersion: 'os_major_version',
    TotalSystemCount: 'total_system_count',
    BusinessObjective: 'business_objective',
    ComplianceThreshold: 'compliance_threshold',
    Titleasc: 'title:asc',
    Titledesc: 'title:desc',
    OsMajorVersionasc: 'os_major_version:asc',
    OsMajorVersiondesc: 'os_major_version:desc',
    TotalSystemCountasc: 'total_system_count:asc',
    TotalSystemCountdesc: 'total_system_count:desc',
    BusinessObjectiveasc: 'business_objective:asc',
    BusinessObjectivedesc: 'business_objective:desc',
    ComplianceThresholdasc: 'compliance_threshold:asc',
    ComplianceThresholddesc: 'compliance_threshold:desc'
} as const;
export type PoliciesSortByEnum = typeof PoliciesSortByEnum[keyof typeof PoliciesSortByEnum];
/**
 * @export
 */
export const PolicySystemsSortByEnum = {
    DisplayName: 'display_name',
    OsMajorVersion: 'os_major_version',
    OsMinorVersion: 'os_minor_version',
    Groups: 'groups',
    DisplayNameasc: 'display_name:asc',
    DisplayNamedesc: 'display_name:desc',
    OsMajorVersionasc: 'os_major_version:asc',
    OsMajorVersiondesc: 'os_major_version:desc',
    OsMinorVersionasc: 'os_minor_version:asc',
    OsMinorVersiondesc: 'os_minor_version:desc',
    Groupsasc: 'groups:asc',
    Groupsdesc: 'groups:desc'
} as const;
export type PolicySystemsSortByEnum = typeof PolicySystemsSortByEnum[keyof typeof PolicySystemsSortByEnum];
/**
 * @export
 */
export const TailoringRulesSortByEnum = {
    Title: 'title',
    Severity: 'severity',
    Precedence: 'precedence',
    Titleasc: 'title:asc',
    Titledesc: 'title:desc',
    Severityasc: 'severity:asc',
    Severitydesc: 'severity:desc',
    Precedenceasc: 'precedence:asc',
    Precedencedesc: 'precedence:desc'
} as const;
export type TailoringRulesSortByEnum = typeof TailoringRulesSortByEnum[keyof typeof TailoringRulesSortByEnum];
/**
 * @export
 */
export const TailoringsSortByEnum = {
    Version: 'os_minor_version',
    Versionasc: 'os_minor_version:asc',
    Versiondesc: 'os_minor_version:desc'
} as const;
export type TailoringsSortByEnum = typeof TailoringsSortByEnum[keyof typeof TailoringsSortByEnum];


/**
 * SystemsApi - axios parameter creator
 * @export
 */
export const SystemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a System
         * @summary Request a System
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        system: async (id: string, xRHIDENTITY?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('system', 'id', id)
            const localVarPath = `/systems/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Systems
         * @summary Request Systems
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<SystemsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systems: async (xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SystemsSortByEnum>, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/systems`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists Policies under a System
         * @summary Request Policies assigned to a System
         * @param {string} systemId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<SystemsPoliciesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemsPolicies: async (systemId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SystemsPoliciesSortByEnum>, filter?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'systemId' is not null or undefined
            assertParamExists('systemsPolicies', 'systemId', systemId)
            const localVarPath = `/systems/{system_id}/policies`
                .replace(`{${"system_id"}}`, encodeURIComponent(String(systemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (filter !== undefined) {
                localVarQueryParameter['filter'] = filter;
            }

            if (xRHIDENTITY != null) {
                localVarHeaderParameter['X-RH-IDENTITY'] = String(xRHIDENTITY);
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemsApi - functional programming interface
 * @export
 */
export const SystemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a System
         * @summary Request a System
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async system(id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<System200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.system(id, xRHIDENTITY, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemsApi.system']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists Systems
         * @summary Request Systems
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<SystemsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systems(xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SystemsSortByEnum>, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Systems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systems(xRHIDENTITY, limit, offset, sortBy, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemsApi.systems']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lists Policies under a System
         * @summary Request Policies assigned to a System
         * @param {string} systemId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<SystemsPoliciesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemsPolicies(systemId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SystemsPoliciesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policies200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemsPolicies(systemId, xRHIDENTITY, limit, offset, sortBy, filter, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SystemsApi.systemsPolicies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SystemsApi - factory interface
 * @export
 */
export const SystemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemsApiFp(configuration)
    return {
        /**
         * Returns a System
         * @summary Request a System
         * @param {string} id
         * @param {string} [xRHIDENTITY]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        system(id: string, xRHIDENTITY?: string, options?: any): AxiosPromise<System200Response> {
            return localVarFp.system(id, xRHIDENTITY, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Systems
         * @summary Request Systems
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<SystemsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systems(xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SystemsSortByEnum>, filter?: string, options?: any): AxiosPromise<Systems200Response> {
            return localVarFp.systems(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists Policies under a System
         * @summary Request Policies assigned to a System
         * @param {string} systemId
         * @param {string} [xRHIDENTITY]
         * @param {number} [limit] Number of items to return per page
         * @param {number} [offset] Offset of first item of paginated response
         * @param {Array<SystemsPoliciesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
         * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemsPolicies(systemId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SystemsPoliciesSortByEnum>, filter?: string, options?: any): AxiosPromise<Policies200Response> {
            return localVarFp.systemsPolicies(systemId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemsApi - object-oriented interface
 * @export
 * @class SystemsApi
 * @extends {BaseAPI}
 */
export class SystemsApi extends BaseAPI {
    /**
     * Returns a System
     * @summary Request a System
     * @param {string} id
     * @param {string} [xRHIDENTITY]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public system(id: string, xRHIDENTITY?: string, options?: RawAxiosRequestConfig) {
        return SystemsApiFp(this.configuration).system(id, xRHIDENTITY, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Systems
     * @summary Request Systems
     * @param {string} [xRHIDENTITY]
     * @param {number} [limit] Number of items to return per page
     * @param {number} [offset] Offset of first item of paginated response
     * @param {Array<SystemsSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Systems are searchable using attributes &#x60;display_name&#x60;, &#x60;os_major_version&#x60;, and &#x60;os_minor_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public systems(xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SystemsSortByEnum>, filter?: string, options?: RawAxiosRequestConfig) {
        return SystemsApiFp(this.configuration).systems(xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lists Policies under a System
     * @summary Request Policies assigned to a System
     * @param {string} systemId
     * @param {string} [xRHIDENTITY]
     * @param {number} [limit] Number of items to return per page
     * @param {number} [offset] Offset of first item of paginated response
     * @param {Array<SystemsPoliciesSortByEnum>} [sortBy] Attribute and direction to sort the items by. Represented by an array of fields with an optional direction (&#x60;&lt;key&gt;:asc&#x60; or &#x60;&lt;key&gt;:desc&#x60;).&lt;br&gt;&lt;br&gt;If no direction is selected, &#x60;&lt;key&gt;:asc&#x60; is used by default.
     * @param {string} [filter] Query string to filter items by their attributes. Compliant with &lt;a href&#x3D;\&quot;https://github.com/wvanbergen/scoped_search/wiki/Query-language\&quot; target&#x3D;\&quot;_blank\&quot; title&#x3D;\&quot;github.com/wvanbergen/scoped_search\&quot;&gt;scoped_search query language&lt;/a&gt;. However, only &#x60;&#x3D;&#x60; or &#x60;!&#x3D;&#x60; (resp. &#x60;&lt;&gt;&#x60;) operators are supported.&lt;br&gt;&lt;br&gt;Policies are searchable using attributes &#x60;title&#x60; and &#x60;os_major_version&#x60;&lt;br&gt;&lt;br&gt;(e.g.: &#x60;(version&#x3D;0.1.47 AND os_major_verision&#x3D;8)&#x60;)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemsApi
     */
    public systemsPolicies(systemId: string, xRHIDENTITY?: string, limit?: number, offset?: number, sortBy?: Array<SystemsPoliciesSortByEnum>, filter?: string, options?: RawAxiosRequestConfig) {
        return SystemsApiFp(this.configuration).systemsPolicies(systemId, xRHIDENTITY, limit, offset, sortBy, filter, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SystemsSortByEnum = {
    DisplayName: 'display_name',
    OsMajorVersion: 'os_major_version',
    OsMinorVersion: 'os_minor_version',
    Groups: 'groups',
    DisplayNameasc: 'display_name:asc',
    DisplayNamedesc: 'display_name:desc',
    OsMajorVersionasc: 'os_major_version:asc',
    OsMajorVersiondesc: 'os_major_version:desc',
    OsMinorVersionasc: 'os_minor_version:asc',
    OsMinorVersiondesc: 'os_minor_version:desc',
    Groupsasc: 'groups:asc',
    Groupsdesc: 'groups:desc'
} as const;
export type SystemsSortByEnum = typeof SystemsSortByEnum[keyof typeof SystemsSortByEnum];
/**
 * @export
 */
export const SystemsPoliciesSortByEnum = {
    Title: 'title',
    OsMajorVersion: 'os_major_version',
    TotalSystemCount: 'total_system_count',
    BusinessObjective: 'business_objective',
    ComplianceThreshold: 'compliance_threshold',
    Titleasc: 'title:asc',
    Titledesc: 'title:desc',
    OsMajorVersionasc: 'os_major_version:asc',
    OsMajorVersiondesc: 'os_major_version:desc',
    TotalSystemCountasc: 'total_system_count:asc',
    TotalSystemCountdesc: 'total_system_count:desc',
    BusinessObjectiveasc: 'business_objective:asc',
    BusinessObjectivedesc: 'business_objective:desc',
    ComplianceThresholdasc: 'compliance_threshold:asc',
    ComplianceThresholddesc: 'compliance_threshold:desc'
} as const;
export type SystemsPoliciesSortByEnum = typeof SystemsPoliciesSortByEnum[keyof typeof SystemsPoliciesSortByEnum];


